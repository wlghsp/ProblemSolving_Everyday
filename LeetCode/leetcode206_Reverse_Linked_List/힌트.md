# LeetCode 206. Reverse Linked List - 초보자 힌트

## 문제 요약
연결 리스트(Linked List)를 **뒤집는** 문제입니다.
- 입력: `1 -> 2 -> 3 -> 4 -> 5`
- 출력: `5 -> 4 -> 3 -> 2 -> 1`

### 예시
```
입력: [1,2,3,4,5]
출력: [5,4,3,2,1]

입력: [1,2]
출력: [2,1]

입력: []
출력: []
```

---

## 💡 핵심 아이디어

연결 리스트를 뒤집는다는 것은 **화살표 방향을 반대로** 바꾸는 것입니다!

```
원래: 1 -> 2 -> 3 -> None
뒤집기: None <- 1 <- 2 <- 3
```

### 방법 1: 반복문 (Iterative) ⭐ 초보자 추천
**포인터 3개**를 사용해서 화살표를 하나씩 뒤집습니다.

**필요한 포인터:**
- `prev`: 이전 노드 (처음엔 None)
- `current`: 현재 노드 (처음엔 head)
- `next`: 다음 노드 (임시 저장용)

**단계별 동작:**
```
1단계: prev=None, current=1->2->3
       None <- 1    2->3

2단계: prev=1, current=2->3
       None <- 1 <- 2    3

3단계: prev=2, current=3
       None <- 1 <- 2 <- 3
```

**핵심 로직:**
```python
prev = None
current = head

while current:
    # 1. 다음 노드 임시 저장 (끊어지기 전에!)
    next_temp = current.next

    # 2. 화살표 뒤집기
    current.next = prev

    # 3. 한 칸씩 전진
    prev = current
    current = next_temp

return prev  # prev가 새로운 head!
```

**왜 이렇게 할까?**
1. `next_temp`에 저장 안 하면?
   - `current.next`를 바꾸는 순간 원래 다음 노드를 잃어버림!
2. `prev`를 반환하는 이유?
   - 마지막엔 `current`가 None이고, `prev`가 마지막 노드(새 head)

---

### 방법 2: 재귀 (Recursive) 🔄
**고급 기법** - 재귀적으로 생각하기

**핵심 아이디어:**
1. 나머지 리스트를 먼저 뒤집고
2. 현재 노드를 끝에 붙이기

```python
def reverseList(head):
    # 베이스 케이스: 빈 리스트 or 노드 1개
    if not head or not head.next:
        return head

    # 나머지를 뒤집기 (재귀)
    new_head = reverseList(head.next)

    # 현재 노드를 끝에 연결
    head.next.next = head
    head.next = None

    return new_head
```

**시각화 (1->2->3):**
```
재귀 호출:
reverseList(1->2->3)
  reverseList(2->3)
    reverseList(3) → 3 반환 (베이스)

되돌아오면서:
3 <- 2    (2.next.next = 2, 2.next = None)
3 <- 2 <- 1 (1.next.next = 1, 1.next = None)
```

---

## 🎯 두 방법 비교

| 방법 | 난이도 | 공간복잡도 | 특징 |
|------|--------|-----------|------|
| 반복문 | ⭐ 쉬움 | O(1) | 직관적, 추천 |
| 재귀 | ⭐⭐ 어려움 | O(n) | 우아하지만 스택 사용 |

**초보자라면?**
→ 무조건 **반복문**부터! 재귀는 나중에 도전해보세요.

---

## 📝 단계별 학습 가이드

### Step 1: 종이에 그려보기
```
1 -> 2 -> 3

포인터 위치 표시하면서 손으로 따라가보기:
prev=None, curr=1
prev=1, curr=2
prev=2, curr=3
prev=3, curr=None (끝!)
```

### Step 2: 반복문 구현
- 포인터 3개 (`prev`, `current`, `next_temp`) 선언
- while 루프로 끝까지 순회
- 매 단계마다 화살표 뒤집기

### Step 3: 엣지 케이스 테스트
- 빈 리스트: `[]`
- 노드 1개: `[1]`
- 노드 2개: `[1,2]`

### Step 4: (선택) 재귀로 도전
- 재귀의 베이스 케이스부터 생각
- 스택 프레임 그려보기

---

## 🤔 자주하는 실수

### 1. next_temp를 안 쓰는 경우
```python
# ❌ 잘못된 코드
current.next = prev
current = current.next  # 이미 prev를 가리킴! 무한루프
```

```python
# ✅ 올바른 코드
next_temp = current.next  # 미리 저장!
current.next = prev
current = next_temp  # 원래 다음으로 이동
```

### 2. 반환값 실수
```python
# ❌ 잘못된 반환
return head  # head는 이제 꼬리(None을 가리킴)

# ✅ 올바른 반환
return prev  # prev가 새로운 머리!
```

### 3. None 체크 안 함
```python
# ❌ head가 None이면?
current = head
while current:  # 첫 번째부터 False

# ✅ 먼저 체크 (선택사항)
if not head:
    return None
```

---

## 💪 핵심 포인트 체크리스트

- [ ] 포인터 3개의 역할 이해했나요? (prev, current, next)
- [ ] 왜 next_temp가 필요한지 이해했나요?
- [ ] while 루프 종료 조건 이해했나요? (`current`가 None)
- [ ] 왜 `prev`를 반환하는지 이해했나요?
- [ ] 빈 리스트와 노드 1개 케이스 처리했나요?

---

## 🎯 시간/공간 복잡도

**반복문 방식:**
- 시간: O(n) - 모든 노드 한 번씩 방문
- 공간: O(1) - 포인터 3개만 사용

**재귀 방식:**
- 시간: O(n) - 모든 노드 한 번씩 방문
- 공간: O(n) - 재귀 스택 깊이

---

## 🚀 추가 도전 과제

1. **반복문으로 먼저 풀기** (필수)
2. 각 단계를 print 찍어서 확인해보기
3. 재귀로 다시 풀어보기 (선택)
4. 비교: 어느 방법이 더 이해하기 쉬운가요?

---

## 💡 디버깅 팁

막혔다면 이렇게 해보세요:
```python
prev = None
current = head

while current:
    print(f"prev={prev.val if prev else None}")
    print(f"current={current.val}")

    next_temp = current.next
    current.next = prev

    prev = current
    current = next_temp
```

화이팅! 이 문제는 Linked List의 **가장 기본적이고 중요한** 문제입니다.
완전히 이해하면 다른 문제들도 쉬워질 거예요! 🔥
