# 219. Contains Duplicate II

## 문제 요약
정수 배열 `nums`와 정수 `k`가 주어졌을 때, `nums[i] == nums[j]`이고 `abs(i - j) <= k`인 서로 다른 인덱스 `i`, `j`가 존재하면 `True` 반환.

## 예시
```
Input: nums = [1,2,3,1], k = 3
Output: True (nums[0] == nums[3], |0-3| = 3 <= 3)

Input: nums = [1,2,3,1,2,3], k = 2
Output: False (같은 값의 인덱스 차이가 모두 3 > 2)
```

## 제약 조건
- 1 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9
- 0 <= k <= 10^5

---

## Level 1 - 방향 힌트
- **Hash Map** 을 사용하면 O(n)에 풀 수 있다
- 각 값이 **마지막으로 나타난 인덱스**를 기록하면 된다

---

## Level 2 - 구조 힌트
```python
def containsNearbyDuplicate(self, nums, k):
    # 1. 값 → 마지막 인덱스를 저장할 해시맵 생성

    # 2. nums를 순회하면서
        # 이미 해시맵에 같은 값이 있고, 인덱스 차이가 k 이하이면?
            # True 반환

        # 현재 값의 인덱스를 해시맵에 저장 (덮어쓰기)

    # 3. 끝까지 못 찾으면 False
```

---

## Level 3 - 전체 풀이

```python
def containsNearbyDuplicate(self, nums, k):
    num_index = {}  # 값 → 마지막으로 나타난 인덱스

    for i, num in enumerate(nums):
        # 같은 값이 이미 있고, 인덱스 차이가 k 이하이면 True
        if num in num_index and i - num_index[num] <= k:
            return True

        # 현재 인덱스로 갱신 (항상 최신 인덱스를 유지)
        # 왜 덮어쓰는가: 오래된 인덱스는 차이가 더 크므로 의미 없음
        num_index[num] = i

    return False  # 조건을 만족하는 쌍이 없음
```

### 복잡도
- 시간: O(n) — 한 번 순회
- 추가 공간: O(n) — 해시맵에 최대 n개 저장 (또는 O(min(n, k))로 Sliding Window 방식 가능)

### 자주하는 실수
- `abs(i - j) <= k`를 `< k`로 쓰는 실수 (등호 포함)
- 해시맵에 인덱스를 갱신하지 않아서 오래된 인덱스와 비교하는 실수

### 다른 접근: Sliding Window + Set
```python
def containsNearbyDuplicate(self, nums, k):
    window = set()
    for i, num in enumerate(nums):
        if num in window:
            return True
        window.add(num)
        if len(window) > k:  # 윈도우 크기 유지
            window.remove(nums[i - k])
    return False
```
- 공간을 O(min(n, k))로 줄일 수 있음

## 유사 문제
- LeetCode 1. Two Sum (Easy) — Hash Map 기본
- LeetCode 217. Contains Duplicate (Easy) — Set 기본
- LeetCode 220. Contains Duplicate III (Hard) — 범위 조건 추가
- 백준 10815. 숫자 카드 (Silver V) — Hash Set 기본
