# 2. Add Two Numbers

## 문제 요약
두 개의 비어있지 않은 연결 리스트가 주어지고, 각 노드는 **역순**으로 저장된 음이 아닌 정수를 나타냅니다. 두 수를 더한 결과를 **역순 연결 리스트**로 반환하세요.

## 예시
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
설명: 342 + 465 = 807 → 역순으로 [7,0,8]

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
설명: 9999999 + 9999 = 10009998 → 역순으로 [8,9,9,9,0,0,0,1]
```

## 제약 조건
- 각 연결 리스트의 노드 개수는 [1, 100]
- 0 <= Node.val <= 9
- 리스트는 선행 0이 없는 숫자를 나타냄 (0 자체 제외)

---

## Level 1 - 방향 힌트
- **67. Add Binary**와 거의 동일한 패턴
- `carry`를 들고 두 리스트를 **동시에 순회**하면서 새 노드를 만든다
- **Dummy head** 기법을 사용하면 편하다

---

## Level 2 - 구조 힌트
```python
def addTwoNumbers(self, l1, l2):
    # 1. Dummy head 생성 (결과 리스트의 시작점)
    dummy = ListNode(0)
    current = dummy
    carry = 0

    # 2. l1, l2 둘 중 하나라도 남아있거나 carry가 있으면 계속
    while l1 or l2 or carry:
        # 각 리스트의 현재 값 가져오기 (없으면 0)

        # 합 계산

        # 새 노드 생성 (val = total % 10)

        # carry 갱신 (total // 10)

        # l1, l2 다음 노드로 이동 (있으면)

    # 3. dummy.next 반환 (실제 결과의 시작)
```

---

## Level 3 - 전체 풀이

```python
def addTwoNumbers(self, l1, l2):
    dummy = ListNode(0)  # Dummy head: 결과 리스트의 시작점
    current = dummy      # 현재 위치 포인터
    carry = 0            # 올림값

    # l1, l2 둘 중 하나라도 남아있거나 carry가 있으면 계속
    # 67번과 같은 패턴: or carry가 핵심
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0  # l1이 없으면 0
        val2 = l2.val if l2 else 0  # l2가 없으면 0

        total = val1 + val2 + carry  # 현재 자릿수 합

        # 새 노드 생성: 현재 자릿수 (total % 10)
        current.next = ListNode(total % 10)
        current = current.next

        carry = total // 10  # 올림값 갱신

        # 다음 노드로 이동 (있으면)
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next  # dummy는 빈 노드, 실제 결과는 dummy.next부터

```

### 복잡도
- 시간: O(max(m, n)) — 긴 리스트 길이만큼 순회
- 추가 공간: O(1) — result는 출력이므로 제외, carry와 포인터만 사용

### 핵심 포인트
1. **Dummy head 기법**: 결과 리스트의 첫 노드를 만들 때 예외처리 불필요
2. **`or carry` 조건**: 67번과 동일하게 마지막 올림을 처리
3. **역순 저장**: 이미 역순이므로 앞에서부터 처리하면 끝

### 자주하는 실수
- `or carry`를 빼먹어서 마지막 올림을 놓침 (예: 999 + 1 = 1000)
- `dummy.next` 대신 `dummy`를 반환
- l1, l2가 None인지 체크 안 하고 `.val` 접근 → AttributeError

### Dummy Head란?
```python
dummy = ListNode(0)  # 실제 데이터가 아닌 빈 노드
current = dummy
# ... 노드 추가 ...
return dummy.next    # dummy는 버리고, 실제 데이터는 그 다음부터
```
- 첫 노드 삽입 시 `if head is None` 같은 예외 처리 불필요
- 코드가 간결해짐

## 유사 문제
- LeetCode 67. Add Binary (Easy) — 문자열 덧셈, 같은 carry 패턴
- LeetCode 445. Add Two Numbers II (Medium) — 정순 저장 버전
- LeetCode 21. Merge Two Sorted Lists (Easy) — 두 리스트 병합
- 백준 1158. 요세푸스 문제 (Silver IV) — 연결 리스트 기본
