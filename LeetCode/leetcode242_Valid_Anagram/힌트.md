# LeetCode 242. Valid Anagram

## 문제 설명
두 문자열 `s`와 `t`가 주어질 때, `t`가 `s`의 애너그램(anagram)인지 판별하세요.

**애너그램(Anagram):** 한 문자열의 문자를 재배열하여 다른 문자열을 만들 수 있는 경우

## 예제

### Example 1:
```
입력: s = "anagram", t = "nagaram"
출력: true
```

### Example 2:
```
입력: s = "rat", t = "car"
출력: false
```

### Example 3:
```
입력: s = "listen", t = "silent"
출력: true
```

## 제약 조건
- `1 <= s.length, t.length <= 5 * 10^4`
- `s`와 `t`는 소문자 영문자로만 구성

## Follow-up
입력 문자열에 유니코드 문자가 포함된 경우 어떻게 해결하시겠습니까?

## 접근 방법

### 방법 1: 정렬 (Sorting) ⭐ 가장 간단
**핵심 아이디어:**
- 두 문자열을 정렬했을 때 같으면 애너그램
- "anagram" → "aaagmnr"
- "nagaram" → "aaagmnr"

**알고리즘:**
1. 두 문자열의 길이가 다르면 즉시 False 반환
2. 각 문자열을 정렬
3. 정렬된 문자열이 같은지 비교

**시간복잡도:** O(n log n)
- 정렬: O(n log n)
- n = 문자열 길이

**공간복잡도:** O(n) 또는 O(1)
- Python의 Timsort는 O(n) 추가 공간 사용
- 정렬 알고리즘에 따라 다름

**구현 팁:**
```python
def isAnagram(self, s: str, t: str) -> bool:
    # 길이가 다르면 애너그램 불가
    if len(s) != len(t):
        return False

    # 정렬 후 비교
    return sorted(s) == sorted(t)

# 한 줄 버전
def isAnagram(self, s: str, t: str) -> bool:
    return sorted(s) == sorted(t)
```

### 방법 2: 해시 테이블 (Hash Map) ⭐ 추천 (최적)
**핵심 아이디어:**
- 각 문자의 출현 횟수를 카운트
- 두 문자열의 문자 빈도가 같으면 애너그램

**알고리즘:**
1. 두 문자열의 길이가 다르면 False
2. 각 문자의 출현 횟수를 딕셔너리에 저장
3. 두 딕셔너리가 같은지 비교

**시간복잡도:** O(n)
- 각 문자를 한 번씩만 순회
- 정렬보다 빠름

**공간복잡도:** O(1)
- 소문자만 사용 → 최대 26개 문자
- 고정된 크기의 딕셔너리

**구현 팁:**
```python
# 방법 2-1: Counter 사용 (가장 간단)
from collections import Counter

def isAnagram(self, s: str, t: str) -> bool:
    return Counter(s) == Counter(t)

# 방법 2-2: 딕셔너리 직접 구현
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    count = {}

    # s의 문자 카운트 증가
    for char in s:
        count[char] = count.get(char, 0) + 1

    # t의 문자 카운트 감소
    for char in t:
        count[char] = count.get(char, 0) - 1

    # 모든 카운트가 0이면 애너그램
    return all(c == 0 for c in count.values())

# 방법 2-3: 딕셔너리 두 개 사용
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    count_s = {}
    count_t = {}

    for char in s:
        count_s[char] = count_s.get(char, 0) + 1

    for char in t:
        count_t[char] = count_t.get(char, 0) + 1

    return count_s == count_t
```

### 방법 3: 배열 카운팅 (Array Counting)
**핵심 아이디어:**
- 소문자만 사용 → 26개 문자
- 크기 26의 배열로 문자 빈도 저장

**시간복잡도:** O(n)
**공간복잡도:** O(1) - 고정 크기 배열

**구현 팁:**
```python
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    # 26개 알파벳 카운트 배열
    count = [0] * 26

    for i in range(len(s)):
        # s의 문자 증가
        count[ord(s[i]) - ord('a')] += 1
        # t의 문자 감소
        count[ord(t[i]) - ord('a')] -= 1

    # 모든 카운트가 0이면 애너그램
    return all(c == 0 for c in count)

# 또는 sum으로 확인
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    count = [0] * 26

    for char in s:
        count[ord(char) - ord('a')] += 1

    for char in t:
        count[ord(char) - ord('a')] -= 1
        # 음수가 되면 애너그램 아님
        if count[ord(char) - ord('a')] < 0:
            return False

    return True
```

## 시각화 예제

### Example 1: s = "anagram", t = "nagaram"

```
방법 1: 정렬
s = "anagram" → sorted → "aaagmnr"
t = "nagaram" → sorted → "aaagmnr"
"aaagmnr" == "aaagmnr" → True ✓

방법 2: 해시 테이블
s = "anagram"
문자 빈도:
{'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1}

t = "nagaram"
문자 빈도:
{'n': 1, 'a': 3, 'g': 1, 'r': 1, 'm': 1}

두 딕셔너리 동일 → True ✓

방법 3: 배열 카운팅
인덱스:  0  1  2  3  4  5 ... 12 13 ... 17
문자:    a  b  c  d  e  f ... m  n ... r
s 카운트: 3  0  0  0  0  0 ... 1  1 ... 1
t 카운트: 3  0  0  0  0  0 ... 1  1 ... 1
차이:    0  0  0  0  0  0 ... 0  0 ... 0
→ True ✓
```

### Example 2: s = "rat", t = "car"

```
방법 1: 정렬
s = "rat" → sorted → "art"
t = "car" → sorted → "acr"
"art" != "acr" → False ✓

방법 2: 해시 테이블
s = "rat"
{'r': 1, 'a': 1, 't': 1}

t = "car"
{'c': 1, 'a': 1, 'r': 1}

't' in s but not in t
'c' in t but not in s
→ False ✓

방법 3: 배열 카운팅
    a  c  r  t
s:  1  0  1  1
t:  1  1  1  0
차: 0 -1  0  1
→ 0이 아닌 값 존재 → False ✓
```

## 주요 포인트

### 1. 길이 확인 최적화
```python
# 길이가 다르면 즉시 반환 (조기 종료)
if len(s) != len(t):
    return False

# 이후 로직 실행
```

### 2. 문자-인덱스 변환
```python
# 'a' → 0, 'b' → 1, ..., 'z' → 25
index = ord(char) - ord('a')

# 예:
ord('a') - ord('a') = 97 - 97 = 0
ord('c') - ord('a') = 99 - 97 = 2
ord('z') - ord('a') = 122 - 97 = 25
```

### 3. Counter 비교
```python
from collections import Counter

# Counter는 딕셔너리의 서브클래스
count_s = Counter("anagram")
# Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1})

count_t = Counter("nagaram")
# Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1})

# 직접 비교 가능
count_s == count_t  # True
```

### 4. 딕셔너리 get 활용
```python
# get(key, default): key가 없으면 default 반환
count = {}
count[char] = count.get(char, 0) + 1

# 또는 defaultdict 사용
from collections import defaultdict
count = defaultdict(int)
count[char] += 1  # 자동으로 0으로 초기화
```

### 5. 엣지 케이스
- 빈 문자열: `s = "", t = ""` → True
- 길이 1: `s = "a", t = "a"` → True
- 길이 다름: `s = "a", t = "ab"` → False
- 문자 종류는 같지만 빈도 다름: `s = "aa", t = "ab"` → False

## Follow-up: 유니코드 문자

```python
# 기존 배열 방식은 사용 불가 (26개 초과)
# 해시 테이블 방식 사용

def isAnagram(self, s: str, t: str) -> bool:
    # Counter 또는 딕셔너리 사용 (유니코드 대응 가능)
    return Counter(s) == Counter(t)

# 예: 한글
s = "안녕하세요"
t = "요세하녕안"
Counter(s) == Counter(t)  # True
```

## 관련 문제
- LeetCode 49. Group Anagrams (애너그램 그룹화)
- LeetCode 438. Find All Anagrams in a String (문자열 내 애너그램 찾기)
- LeetCode 567. Permutation in String (순열 확인)
- LeetCode 383. Ransom Note (문자 사용 가능 여부)

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| 정렬 | O(n log n) | O(n) | 구현 매우 간단 | 느림 |
| 해시 테이블 (Counter) | O(n) | O(1)* | 빠르고 간결 | - |
| 해시 테이블 (직접) | O(n) | O(1)* | 빠름, Counter 없이 가능 | 코드 약간 김 |
| 배열 카운팅 | O(n) | O(1) | 가장 빠름 | 소문자만 가능, 유니코드 불가 |

*소문자만 사용 시 최대 26개로 제한되므로 O(1)

## 추천 풀이

### 1순위: Counter 사용
```python
from collections import Counter

def isAnagram(self, s: str, t: str) -> bool:
    return Counter(s) == Counter(t)
```
- 가장 간결하고 Pythonic
- 유니코드 대응 가능
- 면접에서 선호

### 2순위: 배열 카운팅
```python
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    count = [0] * 26
    for i in range(len(s)):
        count[ord(s[i]) - ord('a')] += 1
        count[ord(t[i]) - ord('a')] -= 1

    return all(c == 0 for c in count)
```
- 최적 성능
- 소문자 영문자만 사용 시

## 디버깅 팁
1. 길이 비교 먼저 확인
2. 문자 빈도 출력해서 확인
3. 엣지 케이스 테스트 (빈 문자열, 길이 1)
4. 대소문자 구분 확인 (문제는 소문자만)

## 성능 최적화

```python
# 1. 길이 체크로 조기 종료
if len(s) != len(t):
    return False

# 2. 단일 순회로 카운트 증감
count = [0] * 26
for i in range(len(s)):
    count[ord(s[i]) - ord('a')] += 1
    count[ord(t[i]) - ord('a')] -= 1

# 3. 조기 종료 (음수 발견 시)
for char in t:
    count[ord(char) - ord('a')] -= 1
    if count[ord(char) - ord('a')] < 0:
        return False  # 즉시 종료
```

## 실전 팁
- **간단한 문제**는 정렬로 빠르게 구현
- **최적화 요구** 시 해시 테이블이나 배열 사용
- **유니코드 대응** 필요 시 Counter 사용
- **공간 복잡도 중요** 시 배열 카운팅 선택
