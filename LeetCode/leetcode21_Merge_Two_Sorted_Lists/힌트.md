# LeetCode 21. Merge Two Sorted Lists

## 문제 설명
두 개의 정렬된 연결 리스트 `list1`과 `list2`의 헤드가 주어집니다.
두 리스트를 하나의 정렬된 리스트로 병합하여 반환하세요.

새로운 리스트는 주어진 두 리스트의 노드들을 이어붙여서 만들어야 합니다.

## 예제

### Example 1:
```
입력: list1 = [1,2,4], list2 = [1,3,4]
출력: [1,1,2,3,4,4]
```

### Example 2:
```
입력: list1 = [], list2 = []
출력: []
```

### Example 3:
```
입력: list1 = [], list2 = [0]
출력: [0]
```

## 제약 조건
- 각 리스트의 노드 개수는 `[0, 50]` 범위
- `-100 <= Node.val <= 100`
- `list1`과 `list2` 모두 오름차순으로 정렬되어 있음

## 접근 방법

### 방법 1: 반복문 (Iterative) - 더미 노드 사용
**핵심 아이디어:**
- 더미 노드를 만들어서 결과 리스트의 시작점을 잡기 쉽게 만듦
- 두 리스트를 비교하면서 작은 값을 계속 연결
- 한 쪽이 끝나면 나머지를 그대로 연결

**알고리즘:**
1. 더미 노드 `dummy`와 현재 위치 포인터 `current` 생성
2. `list1`과 `list2`가 모두 존재하는 동안:
   - 두 리스트의 현재 값을 비교
   - 더 작은 값을 `current.next`에 연결
   - 선택된 리스트와 `current`를 한 칸 전진
3. 남은 리스트가 있으면 그대로 연결 (`current.next = list1 or list2`)
4. `dummy.next` 반환 (더미 다음이 실제 시작점)

**시간복잡도:** O(n + m)
- n = list1의 길이, m = list2의 길이
- 모든 노드를 한 번씩만 방문

**공간복잡도:** O(1)
- 새로운 노드를 만들지 않고 기존 노드를 재사용
- 더미 노드와 포인터만 사용

**구현 팁:**
```python
# 더미 노드 패턴
dummy = ListNode()  # 값은 중요하지 않음
current = dummy

# 비교하면서 연결
while list1 and list2:
    if list1.val <= list2.val:
        current.next = list1
        list1 = list1.next
    else:
        current.next = list2
        list2 = list2.next
    current = current.next

# 남은 부분 처리
current.next = list1 or list2  # 또는 if list1: ... else: ...

return dummy.next  # 더미의 다음부터가 실제 결과
```

### 방법 2: 재귀 (Recursive)
**핵심 아이디어:**
- 작은 문제로 분해: "현재 두 노드 중 작은 것 + 나머지 병합"
- 베이스 케이스: 한 쪽이 비어있으면 다른 쪽 반환

**알고리즘:**
1. 베이스 케이스:
   - `list1`이 None이면 `list2` 반환
   - `list2`가 None이면 `list1` 반환
2. 재귀 케이스:
   - `list1.val <= list2.val`이면:
     - `list1.next = mergeTwoLists(list1.next, list2)`
     - `list1` 반환
   - 그렇지 않으면:
     - `list2.next = mergeTwoLists(list1, list2.next)`
     - `list2` 반환

**시간복잡도:** O(n + m)
- 각 노드마다 한 번씩 재귀 호출

**공간복잡도:** O(n + m)
- 재귀 호출 스택의 깊이 (최악의 경우 모든 노드)

**구현 팁:**
```python
# 베이스 케이스
if not list1:
    return list2
if not list2:
    return list1

# 작은 값을 선택하고 나머지를 재귀로 병합
if list1.val <= list2.val:
    list1.next = self.mergeTwoLists(list1.next, list2)
    return list1
else:
    list2.next = self.mergeTwoLists(list1, list2.next)
    return list2
```

## 주요 포인트

### 1. 더미 노드 (Dummy Node) 패턴
- 연결 리스트 문제에서 자주 사용되는 기법
- 결과 리스트의 시작을 처리하기 쉽게 만듦
- 첫 노드를 특별하게 처리할 필요가 없어짐

### 2. 엣지 케이스
- 한 쪽 또는 양쪽 리스트가 비어있는 경우
- 한 리스트가 다른 리스트보다 훨씬 긴 경우
- 모든 값이 같은 경우

### 3. 비교 연산
- `<=` vs `<`: 같은 값일 때 어느 리스트를 먼저 선택할지
- 안정성(stability): 같은 값의 순서가 유지되는지

## 시각화 예제

```
list1: 1 -> 2 -> 4
list2: 1 -> 3 -> 4

단계별 병합 과정 (반복문):

초기:
dummy ->
list1: 1 -> 2 -> 4
list2: 1 -> 3 -> 4

1단계: list1.val(1) <= list2.val(1) → list1 선택
dummy -> 1
         ↑
list1:      2 -> 4
list2: 1 -> 3 -> 4

2단계: list1.val(2) > list2.val(1) → list2 선택
dummy -> 1 -> 1
              ↑
list1: 2 -> 4
list2:      3 -> 4

3단계: list1.val(2) <= list2.val(3) → list1 선택
dummy -> 1 -> 1 -> 2
                   ↑
list1:      4
list2: 3 -> 4

4단계: list1.val(4) > list2.val(3) → list2 선택
dummy -> 1 -> 1 -> 2 -> 3
                        ↑
list1: 4
list2:      4

5단계: list1.val(4) <= list2.val(4) → list1 선택
dummy -> 1 -> 1 -> 2 -> 3 -> 4
                             ↑
list1: 끝
list2: 4

6단계: list1이 비었으므로 list2 연결
dummy -> 1 -> 1 -> 2 -> 3 -> 4 -> 4

결과: dummy.next 반환
```

## 연습 문제
- LeetCode 23. Merge k Sorted Lists (이 문제의 확장)
- LeetCode 88. Merge Sorted Array (배열 버전)
- LeetCode 148. Sort List (병합 정렬 응용)

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| 반복문 | O(n+m) | O(1) | 공간 효율적, 스택 오버플로우 없음 | 코드가 약간 더 김 |
| 재귀 | O(n+m) | O(n+m) | 코드가 간결하고 우아함 | 긴 리스트에서 스택 오버플로우 위험 |

## 추천 풀이
**반복문 (더미 노드 사용)**
- 더 실용적이고 안전함
- 면접에서 선호되는 방식
- 재귀 버전도 알고 있으면 플러스!
