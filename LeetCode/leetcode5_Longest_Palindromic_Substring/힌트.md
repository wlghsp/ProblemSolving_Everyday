# LeetCode 5. Longest Palindromic Substring

## 문제 설명
문자열 `s`가 주어질 때, `s`에서 가장 긴 회문(palindrome) 부분 문자열을 반환하세요.

**회문(Palindrome):** 앞에서 읽으나 뒤에서 읽으나 같은 문자열

## 예제

### Example 1:
```
입력: s = "babad"
출력: "bab"
설명: "aba"도 정답
```

### Example 2:
```
입력: s = "cbbd"
출력: "bb"
```

### Example 3:
```
입력: s = "a"
출력: "a"
```

### Example 4:
```
입력: s = "ac"
출력: "a" (또는 "c")
```

## 제약 조건
- `1 <= s.length <= 1000`
- `s`는 숫자와 영문자로만 구성

## 접근 방법

### 방법 1: 중앙 확장 (Expand Around Center) ⭐ 추천
**핵심 아이디어:**
- 각 문자(또는 문자 사이)를 중심으로 양쪽으로 확장하며 회문 찾기
- 홀수 길이 회문: 한 문자를 중심으로 확장 (예: "aba")
- 짝수 길이 회문: 두 문자 사이를 중심으로 확장 (예: "abba")

**알고리즘:**
1. 각 인덱스 `i`에 대해:
   - 홀수 길이: `i`를 중심으로 확장 (center = i)
   - 짝수 길이: `i`와 `i+1` 사이를 중심으로 확장
2. 확장 함수:
   - 왼쪽(`left`)과 오른쪽(`right`) 포인터 시작
   - `s[left] == s[right]`인 동안 양쪽으로 확장
   - 더 이상 확장할 수 없으면 길이 반환
3. 가장 긴 회문 추적 및 반환

**시간복잡도:** O(n²)
- n개의 중심점, 각 중심에서 최대 n번 확장
- 최악의 경우: "aaaaaaa" 같은 문자열

**공간복잡도:** O(1)
- 결과 문자열 제외 시 추가 공간 사용 안 함
- 포인터만 사용

**구현 팁:**
```python
def longestPalindrome(self, s: str) -> str:
    def expand_around_center(left: int, right: int) -> int:
        """중심에서 확장하며 회문 길이 반환"""
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1  # 실제 회문 길이

    if not s:
        return ""

    start = 0
    max_len = 0

    for i in range(len(s)):
        # 홀수 길이 회문 (중심이 한 문자)
        len1 = expand_around_center(i, i)
        # 짝수 길이 회문 (중심이 두 문자 사이)
        len2 = expand_around_center(i, i + 1)

        # 더 긴 것 선택
        current_len = max(len1, len2)

        # 최대 길이 갱신
        if current_len > max_len:
            max_len = current_len
            # 시작 위치 계산
            start = i - (current_len - 1) // 2

    return s[start:start + max_len]
```

**시작 위치 계산 설명:**
```
홀수 길이 (len=5, i=3):
  인덱스: 0 1 2 3 4 5 6
  문자열: a b c d c b a
           [←-d-→]
  start = i - (len - 1) // 2 = 3 - 4//2 = 3 - 2 = 1

짝수 길이 (len=4, i=2):
  인덱스: 0 1 2 3 4
  문자열: a b b a
           [b b]
  start = i - (len - 1) // 2 = 2 - 3//2 = 2 - 1 = 1
```

### 방법 2: 동적 계획법 (Dynamic Programming)
**핵심 아이디어:**
- `dp[i][j]` = `s[i:j+1]`이 회문인지 여부
- 작은 부분 문제부터 해결하여 큰 문제로 확장

**점화식:**
```
dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]

베이스 케이스:
- dp[i][i] = True (한 글자는 항상 회문)
- dp[i][i+1] = (s[i] == s[i+1]) (두 글자)
```

**알고리즘:**
1. 2D DP 테이블 생성: `dp[n][n]`
2. 모든 한 글자를 회문으로 초기화: `dp[i][i] = True`
3. 길이별로 순회 (길이 2부터 n까지):
   - 시작 인덱스 `i`를 이동하며
   - 끝 인덱스 `j = i + length - 1` 계산
   - `s[i] == s[j]`이고 내부가 회문이면 → `dp[i][j] = True`
4. 가장 긴 회문 추적 및 반환

**시간복잡도:** O(n²)
- 2D 테이블 채우기

**공간복잡도:** O(n²)
- 2D DP 테이블

**구현 팁:**
```python
def longestPalindrome(self, s: str) -> str:
    n = len(s)
    if n < 2:
        return s

    # DP 테이블 초기화
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_len = 1

    # 한 글자는 항상 회문
    for i in range(n):
        dp[i][i] = True

    # 두 글자 확인
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2

    # 길이 3 이상
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1

            # 양 끝이 같고 내부가 회문이면
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_len = length

    return s[start:start + max_len]
```

### 방법 3: Manacher's Algorithm (고급)
**핵심 아이디어:**
- 선형 시간에 가장 긴 회문을 찾는 최적 알고리즘
- 이전에 계산한 회문 정보를 재활용

**시간복잡도:** O(n)
**공간복잡도:** O(n)

**구현 복잡도:** 높음 (면접에서는 보통 요구하지 않음)

**간략한 아이디어:**
```python
# 홀수/짝수 문제 해결을 위해 특수 문자 삽입
# "babad" → "#b#a#b#a#d#"
# 각 위치에서 회문 반경을 저장하고 재활용
```

## 시각화 예제

### Example: s = "babad"

```
중앙 확장 방식:

인덱스: 0 1 2 3 4
문자열: b a b a d

i=0 (b):
  홀수: b (길이 1)
  짝수: 확장 불가 (b≠a)
  최대: 1

i=1 (a):
  홀수: b a b (길이 3)
       ←a→
  짝수: 확장 불가 (a≠b)
  최대: 3 ✓ (갱신)

i=2 (b):
  홀수: a b a (길이 3)
       ←b→
  짝수: 확장 불가 (b≠a)
  최대: 3

i=3 (a):
  홀수: b a b a d에서 'aba' (길이 3)
         ←a→
  짝수: 확장 불가 (a≠d)
  최대: 3

i=4 (d):
  홀수: d (길이 1)
  짝수: 범위 밖
  최대: 3

결과: "bab" (또는 "aba")
```

### Example: s = "cbbd"

```
인덱스: 0 1 2 3
문자열: c b b d

i=0 (c): 최대 1
i=1 (b):
  홀수: b (길이 1)
  짝수: b b (길이 2) ✓
       [bb]
i=2 (b): 홀수 길이 1, 짝수 확장 불가 (b≠d)
i=3 (d): 최대 1

결과: "bb" (길이 2)
```

### DP 테이블 예제: s = "babad"

```
     j: 0(b) 1(a) 2(b) 3(a) 4(d)
i:
0(b)    T    F    T    F    F
1(a)         T    F    T    F
2(b)              T    F    F
3(a)                   T    F
4(d)                        T

설명:
- 대각선(i=j): 모두 True (한 글자)
- dp[0][2]=T: "bab"는 회문
- dp[1][3]=T: "aba"는 회문
```

## 주요 포인트

### 1. 홀수 vs 짝수 길이 회문
```
홀수 길이: "racecar" (중심이 한 문자)
  중심: e
  확장: race[e]car

짝수 길이: "abba" (중심이 두 문자 사이)
  중심: b|b
  확장: ab[bb]a
```

### 2. 확장 범위 조건
```python
# 확장 가능 조건 (3가지 모두 만족)
while left >= 0 and right < len(s) and s[left] == s[right]:
    # ^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^
    # 1. 왼쪽 범위   2. 오른쪽 범위        3. 문자 일치
```

### 3. 시작 위치 계산
```python
# current_len이 회문 길이, i가 중심일 때
start = i - (current_len - 1) // 2

# 왜 이 공식?
# 홀수: 중심 i, 양쪽으로 (len-1)/2 만큼 확장
# 짝수: 중심 i와 i+1 사이, (len-1)//2 = len//2 - 1
```

### 4. 엣지 케이스
- 한 글자 문자열: `"a"` → `"a"`
- 모두 같은 문자: `"aaaa"` → `"aaaa"`
- 회문이 없음: `"abc"` → `"a"` (또는 "b", "c")
- 빈 문자열: 문제 조건상 발생하지 않음 (길이 >= 1)

### 5. 흔한 실수
```python
# 잘못된 길이 계산
length = right - left  # 틀림!
length = right - left - 1  # 맞음! (while 종료 후 +1씩 초과됨)

# 잘못된 범위 체크
while left > 0 and right < len(s):  # 틀림! (=0일 때도 체크해야 함)
while left >= 0 and right < len(s):  # 맞음!

# 짝수 길이 확인 누락
# 반드시 홀수와 짝수 둘 다 확인!
```

## 관련 문제
- LeetCode 647. Palindromic Substrings (회문 개수 세기)
- LeetCode 516. Longest Palindromic Subsequence (부분 수열)
- LeetCode 214. Shortest Palindrome
- LeetCode 125. Valid Palindrome (회문 검증)

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| 중앙 확장 | O(n²) | O(1) | 공간 효율적, 구현 간단 | - |
| DP | O(n²) | O(n²) | 모든 회문 정보 저장 | 공간 많이 사용 |
| Manacher | O(n) | O(n) | 가장 빠름 | 구현 복잡, 면접에서 드뭄 |
| 브루트포스 | O(n³) | O(1) | 가장 직관적 | 너무 느림 (비추천) |

## 추천 풀이
**중앙 확장 (Expand Around Center)**
- 시간/공간 복잡도 균형이 좋음
- 구현이 명확하고 이해하기 쉬움
- 면접에서 가장 선호되는 방식
- DP는 보조 설명으로 알고 있으면 플러스!

## 디버깅 팁
1. 작은 예제로 손으로 시뮬레이션
2. 홀수/짝수 길이 둘 다 테스트
3. 확장 함수의 반환 값 검증
4. 시작 위치 계산 공식 확인
5. 경계 조건 체크 (left >= 0, right < len(s))

## 최적화 팁
```python
# 1. 더 이상 긴 회문을 찾을 수 없으면 조기 종료
if max_len >= len(s) - i:
    break  # 남은 길이로는 더 긴 회문 불가능

# 2. 문자열이 이미 회문이면 바로 반환
if s == s[::-1]:
    return s

# 3. 확장 함수 인라인화 (성능 미세 개선)
# 함수 호출 오버헤드 제거
```
