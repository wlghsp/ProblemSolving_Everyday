# LeetCode 498. Diagonal Traverse - 힌트

## 문제 요약
m×n 행렬을 **대각선 지그재그 순서**로 읽는 문제입니다.

### 예시
```
입력:
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

대각선 순서:
1 → 2 → 4 → 7 → 5 → 3 → 6 → 8 → 9
 ↗    ↙       ↗       ↙    ↗

출력: [1, 2, 4, 7, 5, 3, 6, 8, 9]
```

```
시각화:
1  2  3
4  5  6
7  8  9

대각선 0: [1]           → 위로 ↗
대각선 1: [2, 4]        → 아래로 ↙ (뒤집어서 4, 2? 아니, 위로 가니까 2, 4)
...
```

### 제약 조건
- m, n: 1 ~ 10,000
- m × n ≤ 10,000
- 값: -10^5 ~ 10^5

---

## Level 1 - 방향 힌트

**시뮬레이션** 문제입니다.
- 핵심 관찰: 같은 대각선 위의 좌표는 `r + c`가 같다
- `r + c`가 짝수면 위로(↗), 홀수면 아래로(↙)
- 경계에 부딪히면 방향 전환

---

## Level 2 - 구조 힌트

```python
def findDiagonalOrder(self, mat):
    # rows, cols 구하기

    # 방향: 위로(↗) = row-1, col+1 / 아래로(↙) = row+1, col-1
    # 시작: (0, 0), 방향: 위로

    # 총 m*n개의 원소를 순회
        # 현재 위치의 값 추가

        # 위로 가는 중이면 (↗)
            # 오른쪽 벽? → 아래로 한 칸, 방향 전환
            # 윗 벽? → 오른쪽 한 칸, 방향 전환
            # 둘 다 아니면? → row-1, col+1

        # 아래로 가는 중이면 (↙)
            # 아래 벽? → 오른쪽 한 칸, 방향 전환
            # 왼쪽 벽? → 아래로 한 칸, 방향 전환
            # 둘 다 아니면? → row+1, col-1
```

---

## Level 3 - 전체 풀이

```python
def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
    if not mat or not mat[0]:
        return []

    rows, cols = len(mat), len(mat[0])
    result = []
    r, c = 0, 0
    going_up = True  # True: ↗ 방향, False: ↙ 방향

    for _ in range(rows * cols):
        result.append(mat[r][c])

        if going_up:  # ↗ 방향 (row 감소, col 증가)
            if c == cols - 1:
                # 오른쪽 벽 → 아래로 이동, 방향 전환
                r += 1
                going_up = False
            elif r == 0:
                # 윗 벽 → 오른쪽 이동, 방향 전환
                c += 1
                going_up = False
            else:
                # 대각선 이동
                r -= 1
                c += 1

        else:  # ↙ 방향 (row 증가, col 감소)
            if r == rows - 1:
                # 아래 벽 → 오른쪽 이동, 방향 전환
                c += 1
                going_up = True
            elif c == 0:
                # 왼쪽 벽 → 아래 이동, 방향 전환
                r += 1
                going_up = True
            else:
                # 대각선 이동
                r += 1
                c -= 1

    return result
```

### 동작 예시

```
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]

(0,0)=1 ↗ → 윗벽+왼벽이지만 오른쪽벽 먼저 체크 → c==0? r==0? → r==0: c+=1
(0,1)=2 ↙ → r+=1, c-=1
(1,0)=4 ↙ → c==0: r+=1, 방향전환
(2,0)=7 ↗ → r-=1, c+=1
(1,1)=5 ↗ → r-=1, c+=1
(0,2)=3 ↗ → c==cols-1: r+=1, 방향전환
(1,2)=6 ↙ → r==rows-1? No → r+=1, c-=1... r==rows-1: c+=1
(2,1)=8 ↙ → r==rows-1: c+=1, 방향전환
(2,2)=9

결과: [1, 2, 4, 7, 5, 3, 6, 8, 9] ✓
```

---

## 🤔 자주하는 실수

### 1. 벽 체크 순서 실수
```python
# ❌ 위로 갈 때: 윗벽을 먼저 체크하면
# 모서리(0, cols-1)에서 잘못된 이동
if r == 0:       # 윗벽 먼저
    c += 1
elif c == cols - 1:
    r += 1

# ✅ 위로 갈 때: 오른쪽 벽을 먼저 체크
if c == cols - 1:   # 오른쪽 벽 먼저!
    r += 1
elif r == 0:
    c += 1
```

### 2. 방향 전환 누락
```python
# ❌ 벽에 부딪혔는데 방향 전환 안 함
if c == cols - 1:
    r += 1
    # going_up = False 빠짐!

# ✅ 반드시 방향 전환
if c == cols - 1:
    r += 1
    going_up = False
```

---

## 🎯 시간/공간 복잡도

- **시간: O(m × n)** - 모든 원소 한 번씩 방문
- **공간: O(1)** - 결과 배열 제외

---

## 🚀 관련 문제

- LeetCode 54: Spiral Matrix (나선형 순회)
- LeetCode 48: Rotate Image (행렬 회전)
- LeetCode 1424: Diagonal Traverse II

화이팅! 행렬 순회 문제는 **방향 전환 조건을 정확히** 파악하는 게 핵심입니다! 🔥
