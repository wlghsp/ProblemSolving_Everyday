# LeetCode 19. Remove Nth Node From End of List

## 문제 설명
연결 리스트의 헤드가 주어질 때, 끝에서 n번째 노드를 제거하고 헤드를 반환하세요.

## 예제

### Example 1:
```
입력: head = [1,2,3,4,5], n = 2
출력: [1,2,3,5]
설명: 끝에서 2번째인 4를 제거

시각화:
1 -> 2 -> 3 -> 4 -> 5
              (제거)
결과: 1 -> 2 -> 3 -> 5
```

### Example 2:
```
입력: head = [1], n = 1
출력: []
설명: 유일한 노드를 제거하면 빈 리스트
```

### Example 3:
```
입력: head = [1,2], n = 1
출력: [1]
설명: 끝에서 1번째인 2를 제거
```

## 제약 조건
- 리스트의 노드 개수: `[1, 30]`
- `0 <= Node.val <= 100`
- `1 <= n <= 리스트 길이`

## 접근 방법

### 방법 1: Two Pointers (투 포인터) - One Pass ⭐ 추천
**핵심 아이디어:**
- 두 포인터를 n칸 간격으로 유지하며 이동
- 빠른 포인터가 끝에 도달하면, 느린 포인터는 제거할 노드의 이전 위치
- **더미 노드** 사용으로 헤드 제거 케이스를 쉽게 처리

**알고리즘:**
1. 더미 노드 생성: `dummy = ListNode(0, head)`
2. 느린 포인터 `slow = dummy`, 빠른 포인터 `fast = dummy`
3. `fast`를 n+1칸 앞으로 이동 (slow와 n칸 간격 유지)
4. `fast`와 `slow`를 동시에 끝까지 이동
   - `fast`가 끝에 도달하면 `slow`는 제거할 노드의 바로 이전
5. 노드 제거: `slow.next = slow.next.next`
6. `dummy.next` 반환 (실제 헤드)

**시간복잡도:** O(L)
- L = 리스트 길이
- **한 번의 순회**로 해결 (One Pass)

**공간복잡도:** O(1)
- 추가 공간 사용 없음 (포인터만 사용)

**구현 팁:**
```python
# 더미 노드 생성 (헤드 제거 케이스 처리)
dummy = ListNode(0)
dummy.next = head

slow = fast = dummy

# fast를 n+1칸 앞으로
for _ in range(n + 1):
    fast = fast.next

# 둘 다 끝까지 이동
while fast:
    slow = slow.next
    fast = fast.next

# 노드 제거
slow.next = slow.next.next

return dummy.next
```

**왜 n+1칸일까?**
```
리스트: 1 -> 2 -> 3 -> 4 -> 5, n = 2
목표: 4 제거 (끝에서 2번째)

n+1 = 3칸 앞으로:
slow      fast
 ↓         ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

이후 동시 이동:
              slow      fast
               ↓         ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

slow.next = 4 (제거할 노드)
slow.next.next = 5

결과: slow.next = 5 (4를 건너뜀)
```

### 방법 2: Two Pass (두 번 순회)
**핵심 아이디어:**
1. 첫 번째 순회: 리스트 길이 L 계산
2. 두 번째 순회: 앞에서 (L-n)번째 노드까지 이동
3. 노드 제거

**알고리즘:**
1. 더미 노드 생성
2. 리스트 길이 L 계산
3. (L-n)번째 노드까지 이동
4. 노드 제거

**시간복잡도:** O(L)
- 두 번 순회하지만 여전히 O(L)

**공간복잡도:** O(1)

**구현 팁:**
```python
dummy = ListNode(0, head)

# 1. 길이 계산
length = 0
current = head
while current:
    length += 1
    current = current.next

# 2. (length - n)번째까지 이동
current = dummy
for _ in range(length - n):
    current = current.next

# 3. 노드 제거
current.next = current.next.next

return dummy.next
```

**단점:**
- Two Pass 방식 (One Pass가 더 우아함)
- 면접에서 Follow-up으로 One Pass 요구될 수 있음

### 방법 3: 스택 사용
**핵심 아이디어:**
- 모든 노드를 스택에 푸시
- n번 팝하면 제거할 노드 도달

**단점:**
- 공간복잡도 O(n)
- 비효율적

## 시각화 예제

### Two Pointers (One Pass) 상세 과정

```
리스트: 1 -> 2 -> 3 -> 4 -> 5, n = 2

1단계: 더미 노드 생성
slow, fast
  ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

2단계: fast를 n+1=3칸 앞으로
slow           fast
  ↓             ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None
        (간격 = 3칸)

3단계: 둘 다 한 칸씩 이동
         slow           fast
           ↓             ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

4단계: 둘 다 한 칸씩 이동
              slow           fast
                ↓             ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

5단계: 둘 다 한 칸씩 이동 (fast가 끝에 도달)
                   slow           fast
                     ↓             ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

6단계: 노드 제거 (slow.next = slow.next.next)
                   slow
                     ↓
dummy -> 1 -> 2 -> 3 -----> 5 -> None
                        4 (제거됨)

결과: dummy.next = 1 -> 2 -> 3 -> 5
```

### 헤드 제거 케이스 (중요!)

```
리스트: 1 -> 2, n = 2 (헤드를 제거해야 함)

1단계: 더미 노드 생성
slow, fast
  ↓
dummy -> 1 -> 2 -> None

2단계: fast를 n+1=3칸 앞으로
slow           fast
  ↓             ↓
dummy -> 1 -> 2 -> None

3단계: fast가 None에 도달 (slow는 dummy)
slow           fast
  ↓             ↓
dummy -> 1 -> 2 -> None

4단계: 노드 제거 (slow.next = slow.next.next)
slow
  ↓
dummy -----> 2 -> None
        1 (제거됨)

결과: dummy.next = 2

더미 노드가 없었다면?
- 헤드 제거를 특별히 처리해야 함
- 더미 노드 덕분에 모든 케이스를 동일하게 처리!
```

## 주요 포인트

### 1. 더미 노드 (Dummy Node)의 중요성
**왜 필요한가?**
- 헤드를 제거하는 경우 특별 처리 필요 없음
- 모든 노드를 동일한 방식으로 처리 가능
- 코드가 간결해짐

**더미 노드 없이 헤드 제거:**
```python
# 복잡한 방식
if length - n == 0:  # 헤드 제거
    return head.next
else:
    # 일반적인 제거 로직
    ...
```

**더미 노드 사용:**
```python
# 간결한 방식
dummy = ListNode(0, head)
# ... 제거 로직 (모든 케이스 동일)
return dummy.next  # 헤드가 바뀌어도 OK
```

### 2. n+1칸 vs n칸
```
n칸만 이동하면?
slow    fast
  ↓      ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

최종:
                slow    fast
                  ↓      ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

slow는 제거할 노드(4)를 가리킴
→ 이전 노드(3)에 접근할 수 없음!

n+1칸 이동하면:
slow         fast
  ↓           ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

최종:
                   slow         fast
                     ↓           ↓
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> None

slow는 제거할 노드의 이전 노드(3)를 가리킴
→ slow.next = slow.next.next로 제거 가능!
```

### 3. 엣지 케이스
- **노드 1개, n=1:** 헤드 제거 → 빈 리스트 반환
- **헤드 제거:** n = 리스트 길이
- **마지막 노드 제거:** n = 1
- **모든 n은 유효함** (문제 조건)

### 4. 흔한 실수
```python
# 실수 1: fast를 n칸만 이동
for _ in range(n):  # 잘못됨!
    fast = fast.next

# 올바른 방법
for _ in range(n + 1):
    fast = fast.next

# 실수 2: 더미 노드 없이 헤드 제거 처리 누락
if n == length:
    return head.next  # 이 체크를 빼먹으면 에러!

# 올바른 방법: 더미 노드 사용
dummy = ListNode(0, head)
# ... (헤드 제거 자동 처리)
return dummy.next

# 실수 3: None 체크 누락
for _ in range(n + 1):
    fast = fast.next  # fast가 None이면 에러!

# 올바른 방법
for _ in range(n + 1):
    if fast:  # 안전 체크 (문제 조건상 불필요하지만 안전)
        fast = fast.next
```

## Follow-up
**Can you do this in one pass?**
→ 네! Two Pointers 방식이 바로 One Pass 솔루션입니다.

## 관련 문제
- LeetCode 2. Add Two Numbers
- LeetCode 21. Merge Two Sorted Lists
- LeetCode 61. Rotate List
- LeetCode 82. Remove Duplicates from Sorted List II

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | Pass 횟수 | 장점 | 단점 |
|------|-----------|-----------|---------|------|------|
| Two Pointers | O(L) | O(1) | 1 | 최적, 우아함 | 초보자에게 어려울 수 있음 |
| Two Pass | O(L) | O(1) | 2 | 직관적 | One Pass가 아님 |
| Stack | O(L) | O(L) | 1 | - | 공간 낭비 |

## 추천 풀이
**Two Pointers with Dummy Node (One Pass)**
- 최적의 시간/공간 복잡도
- 헤드 제거 케이스를 우아하게 처리
- 면접에서 가장 선호되는 방식
- Follow-up 질문에 대한 완벽한 답변

## 디버깅 팁
1. 더미 노드를 그림으로 그리며 이해
2. n+1칸과 n칸의 차이 명확히 구분
3. 헤드 제거 케이스를 반드시 테스트
4. 노드 1개 케이스 테스트
5. 포인터 위치를 단계별로 출력하며 디버깅

## 코드 템플릿
```python
def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
    # 1. 더미 노드 생성
    dummy = ListNode(0, head)
    slow = fast = dummy

    # 2. fast를 n+1칸 앞으로
    for _ in range(n + 1):
        fast = fast.next

    # 3. 둘 다 끝까지 이동
    while fast:
        slow = slow.next
        fast = fast.next

    # 4. 노드 제거
    slow.next = slow.next.next

    # 5. 결과 반환
    return dummy.next
```
