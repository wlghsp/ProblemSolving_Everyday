# LeetCode 257. Binary Tree Paths

## 문제 설명
이진 트리의 루트가 주어질 때, 루트에서 리프까지의 모든 경로를 반환하세요. 경로는 어떤 순서로든 반환할 수 있습니다.

**리프 노드(Leaf node):** 자식이 없는 노드

## 예제

### Example 1:
```
입력: root = [1,2,3,null,5]
     1
    / \
   2   3
    \
     5
출력: ["1->2->5", "1->3"]
```

### Example 2:
```
입력: root = [1]
출력: ["1"]
```

### Example 3:
```
입력: root = [1,2]
     1
    /
   2
출력: ["1->2"]
```

## 제약 조건
- 트리의 노드 개수는 `[1, 100]` 범위
- `-100 <= Node.val <= 100`

## 접근 방법

### 방법 1: DFS - 재귀 (Recursive) ⭐ 추천
**핵심 아이디어:**
- 루트부터 시작해서 현재까지의 경로를 문자열로 추적
- 리프 노드에 도달하면 경로를 결과에 추가
- 왼쪽/오른쪽 자식으로 재귀 호출

**알고리즘:**
1. 베이스 케이스:
   - 노드가 None이면 종료
   - 리프 노드면 현재 경로를 결과에 추가
2. 재귀 케이스:
   - 현재 노드 값을 경로에 추가
   - 왼쪽 자식으로 재귀 (있으면)
   - 오른쪽 자식으로 재귀 (있으면)

**시간복잡도:** O(n)
- 모든 노드를 한 번씩 방문
- n = 노드 개수

**공간복잡도:** O(h)
- 재귀 호출 스택의 깊이
- h = 트리의 높이
- 최악의 경우 O(n) (편향 트리)

**구현 팁:**
```python
def binaryTreePaths(self, root: TreeNode) -> list[str]:
    result = []

    def dfs(node, path):
        if not node:
            return

        # 현재 노드를 경로에 추가
        path += str(node.val)

        # 리프 노드인 경우
        if not node.left and not node.right:
            result.append(path)
            return

        # 자식이 있으면 화살표 추가하고 재귀
        path += "->"
        dfs(node.left, path)
        dfs(node.right, path)

    dfs(root, "")
    return result
```

**다른 방식 - 리스트로 경로 관리:**
```python
def binaryTreePaths(self, root: TreeNode) -> list[str]:
    result = []

    def dfs(node, path):
        if not node:
            return

        # 현재 노드를 경로 리스트에 추가
        path.append(str(node.val))

        # 리프 노드인 경우
        if not node.left and not node.right:
            result.append("->".join(path))
        else:
            # 왼쪽과 오른쪽 자식 탐색
            dfs(node.left, path)
            dfs(node.right, path)

        # 백트래킹: 경로에서 현재 노드 제거
        path.pop()

    dfs(root, [])
    return result
```

### 방법 2: DFS - 반복문 (Iterative with Stack)
**핵심 아이디어:**
- 스택을 사용해서 (노드, 현재경로) 쌍을 저장
- 스택에서 하나씩 꺼내며 처리

**알고리즘:**
1. 스택에 (root, root값) 추가
2. 스택이 빌 때까지:
   - (노드, 경로) 꺼내기
   - 리프 노드면 결과에 추가
   - 자식이 있으면 스택에 추가

**시간복잡도:** O(n)
**공간복잡도:** O(n) - 스택 크기

**구현 팁:**
```python
def binaryTreePaths(self, root: TreeNode) -> list[str]:
    if not root:
        return []

    result = []
    stack = [(root, str(root.val))]

    while stack:
        node, path = stack.pop()

        # 리프 노드인 경우
        if not node.left and not node.right:
            result.append(path)
            continue

        # 오른쪽 자식 (스택이므로 나중에 처리됨)
        if node.right:
            stack.append((node.right, path + "->" + str(node.right.val)))

        # 왼쪽 자식 (스택이므로 먼저 처리됨)
        if node.left:
            stack.append((node.left, path + "->" + str(node.left.val)))

    return result
```

### 방법 3: BFS (Level Order Traversal)
**핵심 아이디어:**
- 큐를 사용해서 레벨 순서로 탐색
- 각 노드와 함께 현재까지의 경로 저장

**시간복잡도:** O(n)
**공간복잡도:** O(n)

**구현 팁:**
```python
from collections import deque

def binaryTreePaths(self, root: TreeNode) -> list[str]:
    if not root:
        return []

    result = []
    queue = deque([(root, str(root.val))])

    while queue:
        node, path = queue.popleft()

        # 리프 노드인 경우
        if not node.left and not node.right:
            result.append(path)
            continue

        # 왼쪽 자식
        if node.left:
            queue.append((node.left, path + "->" + str(node.left.val)))

        # 오른쪽 자식
        if node.right:
            queue.append((node.right, path + "->" + str(node.right.val)))

    return result
```

## 시각화 예제

### Example: [1,2,3,null,5]

```
트리 구조:
      1
     / \
    2   3
     \
      5

DFS 재귀 과정:

1. dfs(1, "")
   path = "1"
   not leaf → 자식 탐색

2. dfs(2, "1->")
   path = "1->2"
   not leaf → 자식 탐색

3. dfs(null, "1->2->")  # 왼쪽 자식 없음
   return

4. dfs(5, "1->2->")
   path = "1->2->5"
   leaf! → result.append("1->2->5") ✓

5. dfs(3, "1->")
   path = "1->3"
   leaf! → result.append("1->3") ✓

최종 결과: ["1->2->5", "1->3"]
```

### 백트래킹 방식 (리스트 사용):

```
트리: [1,2,3,null,5]

1. dfs(1, [])
   path = ["1"]
   not leaf

2. dfs(2, ["1"])
   path = ["1", "2"]
   not leaf

3. dfs(null, ["1", "2"])
   return

4. dfs(5, ["1", "2"])
   path = ["1", "2", "5"]
   leaf! → result.append("1->2->5")
   path.pop() → ["1", "2"]  # 백트래킹

5. path.pop() → ["1"]  # 백트래킹

6. dfs(3, ["1"])
   path = ["1", "3"]
   leaf! → result.append("1->3")
   path.pop() → ["1"]  # 백트래킹

결과: ["1->2->5", "1->3"]
```

## 주요 포인트

### 1. 리프 노드 확인
```python
# 리프 노드: 왼쪽과 오른쪽 자식이 모두 없음
if not node.left and not node.right:
    # 리프 노드

# 잘못된 확인 (자식이 하나만 있는 경우 놓침)
if node.left is None or node.right is None:  # 틀림!
```

### 2. 경로 문자열 구성
```python
# 방법 1: 문자열 직접 연결
path = "1"
path += "->"
path += "2"  # "1->2"

# 방법 2: 리스트 사용 후 join
path = ["1", "2", "5"]
result = "->".join(path)  # "1->2->5"

# 방법 3: f-string
path = f"{prev_path}->{node.val}"
```

### 3. 백트래킹 필요성
```python
# 문자열 사용 - 백트래킹 불필요 (불변)
def dfs(node, path):
    path += str(node.val)  # 새 문자열 생성
    dfs(node.left, path)   # 원본 path 유지됨

# 리스트 사용 - 백트래킹 필요 (가변)
def dfs(node, path):
    path.append(str(node.val))  # 리스트 수정
    dfs(node.left, path)        # 리스트 공유됨
    path.pop()                  # 복원 필요!
```

### 4. None 체크
```python
# 재귀 시작 시 체크
def dfs(node, path):
    if not node:
        return
    # ...

# 또는 호출 전에 체크
if node.left:
    dfs(node.left, path)
if node.right:
    dfs(node.right, path)
```

### 5. 엣지 케이스
- 단일 노드 (리프 = 루트): `[1]` → `["1"]`
- 편향 트리 (한쪽으로만): `[1,2,null,3]` → `["1->2->3"]`
- 완전 이진 트리: 여러 경로
- None 입력: 문제 조건상 없음 (노드 최소 1개)

## 관련 문제
- LeetCode 112. Path Sum (경로 합 확인)
- LeetCode 113. Path Sum II (특정 합의 모든 경로)
- LeetCode 437. Path Sum III (경로 개수)
- LeetCode 988. Smallest String Starting From Leaf (리프에서 루트)

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| DFS 재귀 (문자열) | O(n) | O(h) | 간결, 백트래킹 불필요 | 문자열 복사 비용 |
| DFS 재귀 (리스트) | O(n) | O(h) | 메모리 효율적 | 백트래킹 필요 |
| DFS 반복문 | O(n) | O(n) | 명시적 스택 | 코드 약간 복잡 |
| BFS | O(n) | O(n) | 레벨 순서 탐색 | 큐 메모리 사용 |

## 추천 풀이
**DFS 재귀 (문자열 방식)**
- 가장 직관적이고 구현이 간단
- 트리 문제의 기본 패턴
- 면접에서 선호됨

## 디버깅 팁
1. 리프 노드 조건 확인 (양쪽 모두 None)
2. 경로 문자열 형식 확인 ("->")
3. None 노드 처리
4. 재귀 호출 순서 (왼쪽 먼저 vs 오른쪽 먼저는 결과에 영향 없음)

## 최적화 팁
```python
# 1. 조기 종료 (빈 트리)
if not root:
    return []

# 2. 문자열 대신 리스트로 경로 관리 (메모리)
# 단, 백트래킹 필요

# 3. 결과 리스트 전달 대신 반환 (함수형)
def dfs(node, path):
    if not node:
        return []

    path = path + [str(node.val)]

    if not node.left and not node.right:
        return ["->".join(path)]

    return dfs(node.left, path) + dfs(node.right, path)
```
