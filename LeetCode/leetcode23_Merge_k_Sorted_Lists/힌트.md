# LeetCode 23. Merge k Sorted Lists - 초보자 힌트

## 문제 요약
**k개의 정렬된** 연결 리스트를 **하나의 정렬된** 리스트로 합치는 문제입니다.
- 난이도: **Hard** (어려움!)
- 하지만 단계별로 접근하면 풀 수 있어요!

### 예시
```
입력:
[
  1->4->5,
  1->3->4,
  2->6
]

출력: 1->1->2->3->4->4->5->6
```

---

## 💡 핵심 아이디어

이 문제는 여러 방법으로 풀 수 있습니다. 쉬운 것부터 최적화까지!

---

## 방법 1: 모든 값 모아서 정렬하기 (Brute Force) 🔰

**가장 직관적인 방법!** 초보자 추천

**단계:**
1. 모든 리스트를 순회하면서 값들을 배열에 모으기
2. 배열을 정렬하기
3. 정렬된 배열로 새 연결 리스트 만들기

```python
# 의사코드
values = []

# 1. 모든 값 수집
for linked_list in lists:
    current = linked_list
    while current:
        values.append(current.val)
        current = current.next

# 2. 정렬
values.sort()

# 3. 새 리스트 생성
dummy = ListNode(0)
current = dummy
for val in values:
    current.next = ListNode(val)
    current = current.next

return dummy.next
```

**장점:**
- 이해하기 쉬움
- 구현이 간단

**단점:**
- 공간 복잡도 O(n) - 모든 값을 저장
- 정렬된 상태를 활용 못함

**복잡도:**
- 시간: O(N log N) - N은 전체 노드 개수
- 공간: O(N) - 배열에 모든 값 저장

---

## 방법 2: 두 개씩 합치기 (Divide and Conquer) ⭐

**더 효율적!** - 이미 정렬된 상태를 활용

**핵심:** 2개 리스트 합치는 것은 쉬워요! (LeetCode 21번)

**전략:**
```
리스트가 4개라면:
[L1, L2, L3, L4]

1라운드: 두 개씩 합치기
merge(L1, L2) = L12
merge(L3, L4) = L34
[L12, L34]

2라운드: 또 두 개씩
merge(L12, L34) = 최종 결과!
```

**구현 단계:**

### Step 1: 2개 리스트 합치는 함수 만들기
```python
def mergeTwoLists(l1, l2):
    """두 개의 정렬된 리스트를 합치기"""
    dummy = ListNode(0)
    current = dummy

    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    # 남은 것 붙이기
    current.next = l1 if l1 else l2

    return dummy.next
```

### Step 2: k개를 두 개씩 합치기
```python
def mergeKLists(lists):
    if not lists:
        return None

    # 리스트가 1개 남을 때까지 반복
    while len(lists) > 1:
        merged = []

        # 두 개씩 짝지어서 합치기
        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if i + 1 < len(lists) else None
            merged.append(mergeTwoLists(l1, l2))

        lists = merged

    return lists[0]
```

**복잡도:**
- 시간: O(N log k) - N: 전체 노드, k: 리스트 개수
- 공간: O(1) - 추가 리스트만 사용 (재귀 스택 제외)

---

## 방법 3: 우선순위 큐 (Min Heap) 사용 🚀

**가장 효율적!** - Python의 `heapq` 활용

**아이디어:**
- 각 리스트의 **첫 노드**를 힙에 넣기
- 가장 작은 것을 꺼내서 결과에 추가
- 꺼낸 노드의 다음 노드를 힙에 추가

**왜 힙을 쓸까?**
- k개 중에서 최솟값 찾기: O(k)
- 힙 사용하면: O(log k)

```python
import heapq

def mergeKLists(lists):
    # 힙 초기화
    heap = []

    # 각 리스트의 첫 노드를 힙에 추가
    for i, node in enumerate(lists):
        if node:
            # (값, 인덱스, 노드) 형태로 저장
            heapq.heappush(heap, (node.val, i, node))

    dummy = ListNode(0)
    current = dummy

    while heap:
        # 가장 작은 노드 꺼내기
        val, i, node = heapq.heappop(heap)

        # 결과에 추가
        current.next = node
        current = current.next

        # 다음 노드를 힙에 추가
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))

    return dummy.next
```

**주의사항:**
- `heapq`는 튜플의 첫 번째 요소로 비교
- `(node.val, i, node)` 형태: 값이 같으면 인덱스로 비교

**복잡도:**
- 시간: O(N log k) - 각 노드마다 힙 연산
- 공간: O(k) - 힙에 최대 k개 저장

---

## 🎯 방법 비교

| 방법 | 난이도 | 시간복잡도 | 공간복잡도 | 추천 |
|------|--------|-----------|-----------|------|
| 1. 모아서 정렬 | ⭐ 쉬움 | O(N log N) | O(N) | 처음 풀 때 |
| 2. 두 개씩 합치기 | ⭐⭐ 보통 | O(N log k) | O(1) | 이해하기 좋음 |
| 3. 힙 사용 | ⭐⭐⭐ 어려움 | O(N log k) | O(k) | 가장 효율적 |

---

## 📝 단계별 학습 가이드

### 초보자 경로 (추천!)

#### Step 1: 방법 1로 먼저 풀기
- 가장 직관적
- 통과하는 게 목표!

#### Step 2: LeetCode 21번 먼저 풀기
- "Merge Two Sorted Lists" 문제
- 2개 합치는 것부터 마스터

#### Step 3: 방법 2로 업그레이드
- 21번 풀이를 재활용
- k개를 2개씩 합치기

#### Step 4: (선택) 방법 3으로 도전
- 힙(Heap) 자료구조 공부
- 우선순위 큐 개념 이해

---

## 🤔 자주하는 실수

### 1. 빈 리스트 처리 안 함
```python
# ❌ 잘못된 코드
lists = [[], [1]]  # 빈 리스트가 섞여있으면?

# ✅ 올바른 처리
if not lists or len(lists) == 0:
    return None

# 빈 리스트 제거
lists = [l for l in lists if l]
```

### 2. 두 개씩 합칠 때 홀수 개 처리
```python
# lists가 3개라면? [L1, L2, L3]
for i in range(0, len(lists), 2):
    l1 = lists[i]
    l2 = lists[i + 1] if i + 1 < len(lists) else None  # ✅ 체크 필요!
```

### 3. 힙에서 노드 비교 오류
```python
# ❌ ListNode는 비교 불가
heapq.heappush(heap, (node.val, node))  # 값이 같으면 에러!

# ✅ 인덱스 추가
heapq.heappush(heap, (node.val, i, node))
```

---

## 💪 핵심 포인트 체크리스트

- [ ] 2개 리스트 합치는 함수를 만들 수 있나요?
- [ ] 빈 리스트와 None을 처리했나요?
- [ ] Dummy 노드를 사용하는 이유를 아나요?
- [ ] (힙 방법) heapq 사용법을 아나요?
- [ ] 각 방법의 시간복잡도를 이해했나요?

---

## 🔍 디버깅 팁

### 작은 예제로 테스트
```python
# 리스트 2개부터 시작
lists = [
    ListNode(1, ListNode(4)),
    ListNode(2, ListNode(3))
]

# 예상 출력: 1->2->3->4
```

### 중간 결과 출력
```python
def printList(node):
    vals = []
    while node:
        vals.append(node.val)
        node = node.next
    print(vals)

# 두 개씩 합칠 때마다 출력
merged_result = mergeTwoLists(l1, l2)
printList(merged_result)
```

---

## 🎓 관련 문제 (순서대로 풀기 추천)

1. **LeetCode 21 - Merge Two Sorted Lists** (Easy)
   - 이 문제의 기본! 먼저 풀어보세요

2. **LeetCode 23 - Merge k Sorted Lists** (Hard)
   - 지금 이 문제!

3. **LeetCode 148 - Sort List** (Medium)
   - 연결 리스트 정렬

---

## 🚀 도전 과제

1. **방법 1로 통과하기** (필수)
2. **LeetCode 21번 풀기** (필수)
3. **방법 2로 리팩토링** (추천)
4. **방법 3 (힙) 도전** (선택)
5. 각 방법의 실행 시간 비교해보기

---

## 💡 힌트의 힌트

막혔다면:
- **방법 1이 어렵다면:** 먼저 배열 정렬 문제부터
- **방법 2가 어렵다면:** LeetCode 21번부터!
- **방법 3이 어렵다면:** 힙 자료구조 공부 먼저

**이 문제는 Hard지만**, 작은 문제(2개 합치기)로 나누면 풀 수 있어요!

화이팅! 한 단계씩 차근차근! 🔥
