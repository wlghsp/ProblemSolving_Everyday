# LeetCode 79. Word Search - 초보자 힌트

## 문제 요약
2D 보드(격자)에서 주어진 단어를 **인접한 셀을 따라** 찾는 문제입니다.
- 상하좌우로만 이동 가능
- 같은 셀은 한 번만 사용 가능

### 예시
```
입력:
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"

출력: true

경로: A -> B -> C -> C -> E -> D
```

```
입력:
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "SEE"

출력: true

경로: S -> E -> E
```

```
입력:
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCB"

출력: false
(B를 두 번 사용해야 하는데 같은 셀 재사용 불가)
```

### 제약 조건
- 보드 크기: 1 ≤ m, n ≤ 6
- 단어 길이: 1 ≤ word.length ≤ 15
- 대소문자 영문자만 포함

---

## 💡 핵심 아이디어

이 문제는 **DFS(깊이 우선 탐색) + Backtracking(백트래킹)**으로 해결합니다!

**핵심 개념:**
1. 보드의 각 셀을 시작점으로 시도
2. 상하좌우 4방향 탐색
3. 방문한 셀은 표시 (재방문 방지)
4. 막다른 길이면 되돌아가기 (Backtracking)

---

## 🔑 해결 전략

### 1단계: DFS + Backtracking 이해

**DFS란?**
- 한 방향으로 끝까지 탐색
- 막히면 되돌아가서 다른 방향 시도

**Backtracking이란?**
- 선택을 했다가 → 실패하면 → 선택 취소
- 이 문제에서: 셀을 방문했다가 → 실패하면 → 방문 취소

```
A B C E
S F C S
A D E E

"ABCCED" 찾기:
1. A(0,0) 시작 ✓
2. 우측 B(0,1) ✓
3. 우측 C(0,2) ✓
4. 하단 C(1,2) ✓
5. 하단 E(2,2) ✓
6. 좌측 D(2,1) ✓
→ 성공!
```

### 2단계: 알고리즘 구조

```python
def exist(board, word):
    rows, cols = len(board), len(board[0])

    # 보드의 모든 셀을 시작점으로 시도
    for r in range(rows):
        for c in range(cols):
            if dfs(r, c, 0):  # index 0부터 시작
                return True

    return False

def dfs(r, c, index):
    # 단어 끝까지 찾았으면 성공!
    if index == len(word):
        return True

    # 경계 체크 & 문자 일치 체크
    if (r < 0 or r >= rows or c < 0 or c >= cols or
        board[r][c] != word[index] or visited[r][c]):
        return False

    # 현재 셀 방문 표시
    visited[r][c] = True

    # 4방향 탐색 (상하좌우)
    found = (dfs(r+1, c, index+1) or  # 하
             dfs(r-1, c, index+1) or  # 상
             dfs(r, c+1, index+1) or  # 우
             dfs(r, c-1, index+1))    # 좌

    # Backtracking: 방문 표시 해제
    visited[r][c] = False

    return found
```

### 3단계: 방문 표시 최적화

**방법 1: 별도 visited 배열**
```python
visited = [[False] * cols for _ in range(rows)]
```

**방법 2: 보드 자체를 수정 (공간 절약) ⭐**
```python
# 방문 표시
temp = board[r][c]
board[r][c] = '#'  # 특수 문자로 표시

# ... DFS 탐색 ...

# Backtracking: 원래 값 복구
board[r][c] = temp
```

---

## 📝 전체 코드 (최적화 버전)

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        if not board or not word:
            return False

        rows, cols = len(board), len(board[0])

        def dfs(r, c, index):
            # 베이스 케이스: 단어를 모두 찾음
            if index == len(word):
                return True

            # 경계 체크 & 문자 일치 체크
            if (r < 0 or r >= rows or c < 0 or c >= cols or
                board[r][c] != word[index]):
                return False

            # 현재 셀 임시 저장 & 방문 표시
            temp = board[r][c]
            board[r][c] = '#'

            # 4방향 탐색
            found = (dfs(r + 1, c, index + 1) or
                     dfs(r - 1, c, index + 1) or
                     dfs(r, c + 1, index + 1) or
                     dfs(r, c - 1, index + 1))

            # Backtracking: 원래 값 복구
            board[r][c] = temp

            return found

        # 모든 셀을 시작점으로 시도
        for r in range(rows):
            for c in range(cols):
                if dfs(r, c, 0):
                    return True

        return False
```

---

## 🎯 단계별 동작 예시

**board = [['A','B','C','E']], word = "ABC"**

```
1. 시작: (0,0) 'A' 확인
   board[0][0] = '#' (방문 표시)
   index = 0 ✓

2. 우측: (0,1) 'B' 확인
   board[0][1] = '#'
   index = 1 ✓

3. 우측: (0,2) 'C' 확인
   board[0][2] = '#'
   index = 2 ✓

4. index == len(word) → True 반환!
```

**실패하는 경우:**
```
word = "ABCB"

... A -> B -> C 까지 찾음
C의 4방향 탐색:
- 하단: 'S' ≠ 'B' ✗
- 우측: 'E' ≠ 'B' ✗
- 좌측: '#' (이미 방문한 B) ✗
- 상단: 없음 ✗

→ Backtracking 시작
→ 다른 경로 시도
→ 모두 실패 → False
```

---

## 🤔 자주하는 실수

### 1. Backtracking을 안 함
```python
# ❌ 잘못된 코드
board[r][c] = '#'
found = dfs(...)
# board[r][c] = temp 을 안 함!
# → 다른 경로 탐색 시 문제 발생

# ✅ 올바른 코드
temp = board[r][c]
board[r][c] = '#'
found = dfs(...)
board[r][c] = temp  # 반드시 복구!
```

### 2. 베이스 케이스 순서 실수
```python
# ❌ 잘못된 순서
if board[r][c] != word[index]:  # 먼저 체크하면
    return False
if index == len(word):  # 이미 False 반환됨
    return True

# ✅ 올바른 순서
if index == len(word):  # 성공 조건을 먼저!
    return True
if board[r][c] != word[index]:
    return False
```

### 3. 4방향 탐색을 잘못 씀
```python
# ❌ and를 쓰면 모든 방향이 True여야 함
found = (dfs(r+1, c) and dfs(r-1, c) and ...)

# ✅ or를 써서 하나만 True면 됨
found = (dfs(r+1, c) or dfs(r-1, c) or ...)
```

---

## 🎯 시간/공간 복잡도

**시간 복잡도: O(m × n × 4^L)**
- m × n: 모든 셀 시도
- 4^L: 각 문자마다 4방향 탐색 (L = 단어 길이)
- 실제로는 Backtracking으로 많이 줄어듦

**공간 복잡도: O(L)**
- 재귀 호출 스택 깊이 (단어 길이만큼)
- 보드 수정 방식 사용 시 O(1) 추가 공간

---

## 💪 핵심 포인트 체크리스트

- [ ] DFS와 Backtracking의 차이를 이해했나요?
- [ ] 왜 방문 표시를 했다가 해제하는지 이해했나요?
- [ ] 4방향 탐색을 `or`로 연결하는 이유를 아나요?
- [ ] 베이스 케이스를 올바른 순서로 배치했나요?
- [ ] 경계 조건을 모두 체크했나요?

---

## 🚀 추가 도전 과제

1. **최적화: 조기 종료**
   ```python
   # 단어가 보드에 없는 문자를 포함하면 미리 False
   from collections import Counter
   board_chars = Counter(cell for row in board for cell in row)
   word_chars = Counter(word)

   if not all(word_chars[c] <= board_chars[c] for c in word_chars):
       return False
   ```

2. **관련 문제:**
   - LeetCode 200: Number of Islands (DFS 기초)
   - LeetCode 212: Word Search II (여러 단어 찾기)

---

## 💡 디버깅 팁

막혔다면 이렇게 해보세요:
```python
def dfs(r, c, index, path=""):
    print(f"Visiting ({r},{c}), char={board[r][c]}, index={index}, path={path}")

    if index == len(word):
        print(f"Found! Path: {path}")
        return True

    # ... 나머지 코드 ...

    found = dfs(r+1, c, index+1, path + board[r][c])
    # ...
```

화이팅! Backtracking은 **조합 탐색 문제의 핵심 기법**입니다.
완전히 이해하면 수많은 탐색 문제를 풀 수 있어요! 🔥
