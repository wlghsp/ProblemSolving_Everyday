# LeetCode 909. Snakes and Ladders

## 문제 설명
`n x n` 크기의 정수 행렬 `board`가 주어집니다. 이는 뱀과 사다리 게임판을 나타냅니다.

게임판의 칸은 1부터 n²까지 번호가 매겨져 있으며, **Boustrophedon 방식**(소 경작 방식)으로 번호가 매겨집니다:
- 첫 번째 행은 왼쪽에서 오른쪽으로 1부터 n까지
- 두 번째 행은 오른쪽에서 왼쪽으로 n+1부터 2n까지
- 세 번째 행은 왼쪽에서 오른쪽으로...
- (번갈아가며 방향이 바뀜)

게임판의 칸 번호는 **아래에서 위로** 매겨집니다.

게임 규칙:
1. 1번 칸에서 시작
2. 각 턴마다 주사위(1~6)를 굴려 그만큼 앞으로 이동
3. `board[r][c] != -1`이면 뱀 또는 사다리 → `board[r][c]` 칸으로 이동
4. 목표는 n² 칸에 도달하는 것

n² 칸에 도달하는 **최소 이동 횟수**를 반환하세요. 도달할 수 없으면 `-1`을 반환하세요.

## 예제

### Example 1:
```
입력: board = [
  [-1,-1,-1,-1,-1,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,35,-1,-1,13,-1],
  [-1,-1,-1,-1,-1,-1],
  [-1,15,-1,-1,-1,-1]
]
출력: 4

설명:
번호 매김 (Boustrophedon):
36 35 34 33 32 31
25 26 27 28 29 30
24 23 22 21 20 19
13 14 15 16 17 18
12 11 10  9  8  7
 1  2  3  4  5  6

경로:
1 → 2 (주사위 1)
2 → 15 (2번 칸에 사다리, board[4][1]=15로 이동)
15 → 17 (주사위 2)
17 → 36 (주사위 6으로 23, 하지만 board[3][4]=13이므로 뱀 없이 진행... 실제로는 복잡)

최단 경로: 4번의 이동
```

### Example 2:
```
입력: board = [[-1,-1],[-1,3]]
출력: 1

설명:
번호 매김:
4 3
1 2

경로: 1 → 2 (주사위) → 4 (2번 칸에 사다리, board[0][1]=3... 잘못됨)
실제: 1 → 4로 한 번에 (주사위 3)
```

## 제약 조건
- `n == board.length == board[i].length`
- `2 <= n <= 20`
- `board[i][j]`는 `-1` 또는 `[1, n²]` 범위
- 1번과 n² 칸에는 뱀이나 사다리가 없음

## 접근 방법

### 핵심: BFS (너비 우선 탐색) ⭐
**왜 BFS인가?**
- **최단 경로** 문제 (가중치 없는 그래프)
- 각 칸에서 1~6칸 앞으로 이동 가능 (간선)
- BFS는 처음 도달했을 때가 최단 거리

**핵심 아이디어:**
1. 칸 번호 → 보드 좌표 변환 함수 필요 (Boustrophedon)
2. BFS로 1번부터 탐색 시작
3. 각 칸에서 1~6칸 앞으로 이동 시도
4. 뱀/사다리가 있으면 해당 위치로 이동
5. n² 칸에 도달하면 이동 횟수 반환

### 알고리즘

**1단계: 칸 번호 → 좌표 변환**
```python
def get_position(square, n):
    """
    square: 칸 번호 (1-indexed)
    반환: (row, col) - 0-indexed
    """
    # square를 0-indexed로 변환
    square -= 1

    # 몇 번째 행인지 (아래에서부터)
    row = square // n
    # 실제 보드에서의 행 (위에서부터)
    row = n - 1 - row

    # 몇 번째 열인지
    col = square % n

    # 홀수 행(아래에서 세었을 때)은 오른쪽→왼쪽
    if (n - 1 - row) % 2 == 1:
        col = n - 1 - col

    return (row, col)
```

**시각화 (n=6):**
```
보드 인덱스 (board[r][c]):
[0][0] [0][1] [0][2] [0][3] [0][4] [0][5]
[1][0] [1][1] [1][2] [1][3] [1][4] [1][5]
[2][0] [2][1] [2][2] [2][3] [2][4] [2][5]
[3][0] [3][1] [3][2] [3][3] [3][4] [3][5]
[4][0] [4][1] [4][2] [4][3] [4][4] [4][5]
[5][0] [5][1] [5][2] [5][3] [5][4] [5][5]

칸 번호 매김:
 36  35  34  33  32  31  ← (왼쪽으로)
 25  26  27  28  29  30  → (오른쪽으로)
 24  23  22  21  20  19  ← (왼쪽으로)
 13  14  15  16  17  18  → (오른쪽으로)
 12  11  10   9   8   7  ← (왼쪽으로)
  1   2   3   4   5   6  → (오른쪽으로)

예시:
square = 15 → row = 3, col = 2 → board[3][2]
square = 26 → row = 1, col = 1 → board[1][1]
```

**2단계: BFS 탐색**
```python
def snakesAndLadders(self, board: List[List[int]]) -> int:
    n = len(board)
    target = n * n

    # BFS 초기화
    queue = deque([(1, 0)])  # (현재 칸, 이동 횟수)
    visited = set([1])

    while queue:
        square, moves = queue.popleft()

        # 목적지 도달
        if square == target:
            return moves

        # 주사위: 1~6칸 이동
        for dice in range(1, 7):
            next_square = square + dice

            # 범위 초과
            if next_square > target:
                break

            # 좌표 변환
            row, col = get_position(next_square, n)

            # 뱀/사다리 체크
            if board[row][col] != -1:
                next_square = board[row][col]

            # 방문 체크
            if next_square not in visited:
                visited.add(next_square)
                queue.append((next_square, moves + 1))

    return -1  # 도달 불가능
```

**시간복잡도:** O(n²)
- 각 칸을 최대 한 번씩 방문
- 각 칸에서 최대 6개의 다음 칸 확인

**공간복잡도:** O(n²)
- 큐와 visited 세트

## 시각화 예제

### 상세 BFS 탐색 과정

```
보드 (6x6):
 36  35  34  33  32  31
 25  26  27  28  29  30
 24  23  22  21  20  19
 13  14  15  16  17  18
 12  11  10   9   8   7
  1   2   3   4   5   6

사다리/뱀:
- 2 → 15 (사다리)
- 8 → 13 (뱀)
- 14 → 35 (사다리)

BFS 탐색:

초기: queue = [(1, 0)], visited = {1}

1단계: (1, 0) 처리
  - 주사위 1: 2 → 15 (사다리!) → queue에 (15, 1) 추가
  - 주사위 2: 3 → queue에 (3, 1) 추가
  - 주사위 3: 4 → queue에 (4, 1) 추가
  - 주사위 4: 5 → queue에 (5, 1) 추가
  - 주사위 5: 6 → queue에 (6, 1) 추가
  - 주사위 6: 7 → queue에 (7, 1) 추가
  visited = {1, 15, 3, 4, 5, 6, 7}

2단계: (15, 1) 처리
  - 15 + 1~6 = 16~21 모두 체크
  - 17 → queue에 (17, 2) 추가
  - ...

계속 탐색하다가 36에 도달하면 이동 횟수 반환
```

## 주요 포인트

### 1. Boustrophedon 번호 매김
**핵심 공식:**
```python
def get_position(square, n):
    square -= 1  # 0-indexed로 변환
    row_from_bottom = square // n
    row = n - 1 - row_from_bottom
    col = square % n

    # 홀수 행은 역방향
    if row_from_bottom % 2 == 1:
        col = n - 1 - col

    return (row, col)
```

**이해하기:**
```
n = 6, square = 26

1. square - 1 = 25 (0-indexed)
2. row_from_bottom = 25 // 6 = 4 (아래에서 5번째 행)
3. row = 6 - 1 - 4 = 1 (위에서 2번째 행)
4. col = 25 % 6 = 1
5. row_from_bottom % 2 == 1이므로 홀수 행
   → col = 6 - 1 - 1 = 4
6. 결과: board[1][1]... 아니다, board[1][4]? 재확인 필요
```

### 2. 뱀/사다리 처리
```python
# 다음 칸 계산
next_square = square + dice

# 좌표 변환
row, col = get_position(next_square, n)

# 뱀/사다리 체크
if board[row][col] != -1:
    next_square = board[row][col]  # 이동!

# visited 체크는 최종 next_square로
if next_square not in visited:
    visited.add(next_square)
```

### 3. 방문 체크의 중요성
```python
# 잘못된 방법: 뱀/사다리 전에 체크
if next_square not in visited:  # 실제 도착 칸이 아님!
    if board[row][col] != -1:
        next_square = board[row][col]
    visited.add(next_square)

# 올바른 방법: 뱀/사다리 후에 체크
if board[row][col] != -1:
    next_square = board[row][col]

if next_square not in visited:  # 최종 도착 칸 체크
    visited.add(next_square)
```

### 4. 주사위 범위 체크
```python
for dice in range(1, 7):
    next_square = square + dice

    # 목표를 넘어가면 중단
    if next_square > target:
        break  # 더 이상 의미 없음
```

### 5. 엣지 케이스
- **n=2 (최소 크기):** 4칸만 존재
- **사다리로 바로 목적지:** 1 → n² (이동 1회)
- **뱀이 계속 뒤로:** 최악의 경우 많은 이동
- **도달 불가능:** 모든 경로가 뱀으로 막힌 경우 (드물지만 가능)

## 좌표 변환 디버깅

### 검증 방법
```python
def verify_position(n):
    """n x n 보드의 모든 칸 번호와 좌표 출력"""
    for square in range(1, n * n + 1):
        row, col = get_position(square, n)
        print(f"칸 {square:2d} → board[{row}][{col}]")

verify_position(6)
```

### 예상 출력 (n=6)
```
칸  1 → board[5][0]
칸  2 → board[5][1]
칸  3 → board[5][2]
칸  4 → board[5][3]
칸  5 → board[5][4]
칸  6 → board[5][5]
칸  7 → board[4][5]  (역방향 시작)
칸  8 → board[4][4]
...
칸 36 → board[0][0]
```

## 최적화 팁

### 1. 조기 종료
```python
if square == target:
    return moves  # 즉시 반환
```

### 2. 범위 체크 최적화
```python
for dice in range(1, min(7, target - square + 1)):
    # target을 넘지 않는 범위만 확인
```

### 3. Set 대신 배열
```python
visited = [False] * (n * n + 1)  # 약간 더 빠를 수 있음
```

## 관련 문제
- LeetCode 127. Word Ladder (BFS 최단 경로)
- LeetCode 752. Open the Lock (BFS)
- LeetCode 1162. As Far from Land as Possible (BFS)

## 코드 템플릿
```python
from collections import deque

def snakesAndLadders(self, board: List[List[int]]) -> int:
    n = len(board)
    target = n * n

    def get_position(square):
        square -= 1
        row_from_bottom = square // n
        row = n - 1 - row_from_bottom
        col = square % n
        if row_from_bottom % 2 == 1:
            col = n - 1 - col
        return row, col

    queue = deque([(1, 0)])
    visited = set([1])

    while queue:
        square, moves = queue.popleft()

        if square == target:
            return moves

        for dice in range(1, 7):
            next_square = square + dice
            if next_square > target:
                break

            row, col = get_position(next_square)
            if board[row][col] != -1:
                next_square = board[row][col]

            if next_square not in visited:
                visited.add(next_square)
                queue.append((next_square, moves + 1))

    return -1
```

## 디버깅 팁
1. **좌표 변환 먼저 검증:** 작은 보드(2x2, 3x3)로 테스트
2. **BFS 탐색 과정 출력:** 어느 칸을 방문하는지 확인
3. **뱀/사다리 처리 확인:** 올바른 칸으로 이동하는지
4. **방문 체크 순서:** 뱀/사다리 후에 체크하는지
5. **목표 도달 조건:** `==` 사용, `>=` 아님

이 문제는 **BFS + 좌표 변환**의 조합으로, 좌표 변환만 정확하게 구현하면 나머지는 표준 BFS입니다!
