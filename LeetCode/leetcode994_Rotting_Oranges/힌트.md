# LeetCode 994. Rotting Oranges

## 문제 설명
`m x n` 그리드가 주어집니다. 각 셀은 다음 세 가지 값 중 하나를 가질 수 있습니다:

- `0`: 빈 셀
- `1`: 신선한 오렌지
- `2`: 썩은 오렌지

매 분마다 썩은 오렌지에 **인접한** (상하좌우 4방향) 신선한 오렌지가 썩게 됩니다.

모든 오렌지가 썩는 데 걸리는 **최소 시간(분)**을 반환하세요. 모든 오렌지가 썩을 수 없다면 `-1`을 반환합니다.

## 예제

### Example 1:
```
입력: grid = [[2,1,1],[1,1,0],[0,1,1]]
출력: 4

시각화:
분 0:  2 1 1      분 1:  2 2 1      분 2:  2 2 2
      1 1 0            2 1 0            2 2 0
      0 1 1            0 1 1            0 2 1

분 3:  2 2 2      분 4:  2 2 2
      2 2 0            2 2 0
      0 2 2            0 2 2

모든 오렌지가 썩음 → 4분
```

### Example 2:
```
입력: grid = [[2,1,1],[0,1,1],[1,0,1]]
출력: -1

설명: 왼쪽 아래 모서리의 오렌지(1,0)는 절대 썩을 수 없음
(인접한 셀이 모두 0 또는 경계)
```

### Example 3:
```
입력: grid = [[0,2]]
출력: 0

설명: 신선한 오렌지가 없으므로 0분
```

## 제약 조건
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10`
- `grid[i][j]`는 `0`, `1`, 또는 `2`

## 접근 방법

### 방법 1: BFS (Multi-source BFS) ⭐ 추천
**핵심 아이디어:**
- 모든 썩은 오렌지를 **동시에** 큐에 넣고 시작
- 레벨별로 BFS 수행 → 각 레벨이 1분
- 신선한 오렌지가 남아있으면 -1 반환

**알고리즘:**
1. 초기 설정:
   - 모든 썩은 오렌지(2)의 위치를 큐에 추가
   - 신선한 오렌지(1)의 개수 카운트
2. BFS 수행:
   - 큐에서 현재 레벨의 모든 썩은 오렌지 처리
   - 4방향으로 확인하여 신선한 오렌지를 썩힘
   - 새로 썩은 오렌지를 큐에 추가
   - 시간 증가
3. 결과:
   - 신선한 오렌지가 남아있으면 -1
   - 아니면 경과 시간 반환

**시간복잡도:** O(m × n)
- 모든 셀을 최대 한 번씩 방문
- m = 행 개수, n = 열 개수

**공간복잡도:** O(m × n)
- 큐에 최대 m×n개 저장 가능

**구현 팁:**
```python
from collections import deque

def orangesRotting(self, grid: list[list[int]]) -> int:
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0

    # 초기 상태: 썩은 오렌지와 신선한 오렌지 카운트
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))
            elif grid[r][c] == 1:
                fresh_count += 1

    # 신선한 오렌지가 없으면 0 반환
    if fresh_count == 0:
        return 0

    # 4방향: 상, 하, 좌, 우
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    minutes = 0

    # BFS
    while queue:
        # 현재 분의 모든 썩은 오렌지 처리
        for _ in range(len(queue)):
            r, c = queue.popleft()

            # 4방향 확인
            for dr, dc in directions:
                nr, nc = r + dr, c + dc

                # 범위 체크 및 신선한 오렌지인지 확인
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                    # 오렌지 썩힘
                    grid[nr][nc] = 2
                    fresh_count -= 1
                    queue.append((nr, nc))

        # 1분 경과
        minutes += 1

    # 마지막 분은 새로 썩을 오렌지가 없으므로 -1
    # 신선한 오렌지가 남아있으면 -1, 아니면 minutes - 1
    return minutes - 1 if fresh_count == 0 else -1
```

**중요 포인트:**
```python
# 1. 레벨별 처리 (각 분마다)
for _ in range(len(queue)):  # 현재 큐 크기만큼만 처리
    r, c = queue.popleft()
    # ...

# 2. 마지막 분 처리
# 마지막 레벨 처리 후 minutes가 1 증가되므로 -1 필요
return minutes - 1 if fresh_count == 0 else -1

# 또는 다른 방식:
while queue:
    # 처리...
    if queue:  # 다음 레벨이 있을 때만 증가
        minutes += 1
return minutes if fresh_count == 0 else -1
```

### 방법 2: BFS (시간 표시 방식)
**핵심 아이디어:**
- 큐에 (행, 열, 시간) 저장
- 각 오렌지가 언제 썩었는지 추적

**구현 팁:**
```python
from collections import deque

def orangesRotting(self, grid: list[list[int]]) -> int:
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0

    # 초기화
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))  # (행, 열, 시간)
            elif grid[r][c] == 1:
                fresh_count += 1

    if fresh_count == 0:
        return 0

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    max_time = 0

    while queue:
        r, c, time = queue.popleft()
        max_time = max(max_time, time)

        for dr, dc in directions:
            nr, nc = r + dr, c + dc

            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                grid[nr][nc] = 2
                fresh_count -= 1
                queue.append((nr, nc, time + 1))

    return max_time if fresh_count == 0 else -1
```

## 시각화 예제

### Example 1: grid = [[2,1,1],[1,1,0],[0,1,1]]

```
초기 상태 (분 0):
2 1 1    queue = [(0,0)], fresh_count = 6
1 1 0
0 1 1

분 1:
2 2 1    (0,0)에서 확산
2 1 0    queue = [(0,1), (1,0)], fresh_count = 4
0 1 1

분 2:
2 2 2    (0,1)과 (1,0)에서 확산
2 2 0    queue = [(0,2), (1,1)], fresh_count = 2
0 1 1

분 3:
2 2 2    (0,2)와 (1,1)에서 확산
2 2 0    queue = [(2,1)], fresh_count = 1
0 2 1

분 4:
2 2 2    (2,1)에서 확산
2 2 0    queue = [(2,2)], fresh_count = 0
0 2 2

분 5:
2 2 2    큐 처리 후 fresh_count = 0
2 2 0    minutes = 5, return 5 - 1 = 4 ✓
0 2 2
```

### Example 2: grid = [[2,1,1],[0,1,1],[1,0,1]]

```
초기 상태:
2 1 1    queue = [(0,0)], fresh_count = 5
0 1 1
1 0 1

분 1:
2 2 1    (0,0)에서 확산
0 1 1    queue = [(0,1)], fresh_count = 4
1 0 1

분 2:
2 2 2    (0,1)에서 확산
0 2 1    queue = [(0,2), (1,1)], fresh_count = 2
1 0 1

분 3:
2 2 2    (0,2)와 (1,1)에서 확산
0 2 2    queue = [(1,2)], fresh_count = 1
1 0 1

분 4:
2 2 2    (1,2)에서 확산
0 2 2    queue = [(2,2)], fresh_count = 1 (여전히)
1 0 2

더 이상 확산 불가
fresh_count = 1 > 0
→ return -1 ✓
```

## 주요 포인트

### 1. Multi-source BFS
```python
# 여러 시작점을 동시에 큐에 추가
for r in range(rows):
    for c in range(cols):
        if grid[r][c] == 2:
            queue.append((r, c))  # 모든 썩은 오렌지

# 일반 BFS는 단일 시작점
queue.append(start_position)
```

### 2. 레벨별 처리 (중요!)
```python
# 방법 1: 현재 큐 크기만큼만 처리
while queue:
    level_size = len(queue)  # 현재 레벨의 노드 수
    for _ in range(level_size):
        r, c = queue.popleft()
        # 처리...
    minutes += 1

# 방법 2: 시간 정보 포함
queue.append((r, c, time))
```

### 3. 4방향 탐색
```python
# 상하좌우
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

for dr, dc in directions:
    nr, nc = r + dr, c + dc
    if 0 <= nr < rows and 0 <= nc < cols:
        # 처리...

# 또는 개별적으로
for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
    # ...
```

### 4. 범위 체크
```python
# 올바른 순서: 범위 체크 → 값 체크
if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
    # ...

# 잘못된 순서: 인덱스 에러 가능
if grid[nr][nc] == 1 and 0 <= nr < rows and 0 <= nc < cols:
    # grid[nr][nc]가 먼저 실행되면 에러!
```

### 5. 엣지 케이스
```python
# 케이스 1: 신선한 오렌지 없음
grid = [[0, 2]]
fresh_count = 0 → return 0

# 케이스 2: 썩은 오렌지 없음 (신선한 오렌지만)
grid = [[1, 1]]
queue는 비어있음, fresh_count > 0 → return -1

# 케이스 3: 모든 오렌지가 이미 썩음
grid = [[2, 2]]
fresh_count = 0 → return 0

# 케이스 4: 고립된 신선한 오렌지
grid = [[2,1,1],[0,1,1],[1,0,1]]
(2,0) 위치의 1은 도달 불가 → return -1
```

### 6. 마지막 분 처리
```python
# 문제: 마지막 레벨 처리 후 minutes가 1 더 증가됨
while queue:
    # 레벨 처리...
    minutes += 1  # 큐가 비었어도 증가

# 해결 1: return 시 -1
return minutes - 1 if fresh_count == 0 else -1

# 해결 2: 증가 전 큐 확인
while queue:
    # 레벨 처리...
    if queue:  # 다음 레벨이 있을 때만
        minutes += 1

# 해결 3: -1로 초기화
minutes = -1
while queue:
    # 레벨 처리...
    minutes += 1
```

## 관련 문제
- LeetCode 286. Walls and Gates (BFS, Multi-source)
- LeetCode 542. 01 Matrix (BFS, 최단 거리)
- LeetCode 1091. Shortest Path in Binary Matrix
- LeetCode 200. Number of Islands (DFS/BFS)
- LeetCode 733. Flood Fill

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| Multi-source BFS | O(m×n) | O(m×n) | 최적, 구현 명확 | - |
| BFS (시간 포함) | O(m×n) | O(m×n) | 각 노드 시간 추적 | 약간 더 많은 메모리 |
| DFS | 부적합 | - | - | 동시 확산 표현 불가 |

## 추천 풀이
**Multi-source BFS (레벨별 처리)**
- 가장 직관적이고 효율적
- BFS의 레벨 개념을 명확히 이해
- 면접에서 선호되는 방식

## 디버깅 팁
1. 초기 상태 확인 (썩은 오렌지, 신선한 오렌지 카운트)
2. 레벨별 처리 확인 (각 분마다 정확히 처리)
3. 범위 체크 순서 (인덱스 에러 방지)
4. 마지막 분 처리 (minutes - 1)
5. 엣지 케이스 테스트

## BFS vs DFS

```python
이 문제에 BFS를 사용하는 이유:

1. 동시 확산: 모든 썩은 오렌지가 동시에 확산
   - BFS: 레벨별로 동시 처리 가능 ✓
   - DFS: 한 경로를 끝까지 탐색 (부적합)

2. 최단 시간: 레벨 = 시간
   - BFS: 자연스럽게 최단 거리/시간 ✓
   - DFS: 모든 경로 탐색 필요

3. 시각화:
   BFS: 파도처럼 퍼져나감 (동심원)
   DFS: 한 방향으로 깊게 파고듦
```

## 최적화 팁

```python
# 1. 조기 종료
if fresh_count == 0:
    return 0  # BFS 불필요

# 2. 그리드 수정 (visited 배열 불필요)
grid[nr][nc] = 2  # 방문 표시 겸용

# 3. 방향 배열 사전 정의
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# 4. deque 사용 (list보다 빠름)
from collections import deque
queue = deque()
```

## 실전 팁
- **Multi-source BFS** 패턴 익히기
- **레벨별 처리** 방법 숙지
- **4방향 탐색** 템플릿 암기
- **범위 체크 순서** 주의
- **엣지 케이스** 꼼꼼히 처리
