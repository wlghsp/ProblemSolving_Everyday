# LeetCode 122. Best Time to Buy and Sell Stock II - 힌트

## 문제 요약
주식 가격 배열이 주어질 때, **여러 번 매수/매도**하여 최대 이익을 구하는 문제입니다.
- 같은 날 매도 후 매수 가능
- 동시에 여러 주식 보유 불가

### 예시
```
입력: [7, 1, 5, 3, 6, 4]
출력: 7

설명:
- 1에 매수 → 5에 매도 (이익: 4)
- 3에 매수 → 6에 매도 (이익: 3)
- 총 이익: 4 + 3 = 7
```

```
입력: [1, 2, 3, 4, 5]
출력: 4

설명:
- 1에 매수 → 5에 매도 (이익: 4)
- 또는 매일 매도/매수: (2-1) + (3-2) + (4-3) + (5-4) = 4
```

```
입력: [7, 6, 4, 3, 1]
출력: 0 (계속 하락이므로 거래 안 함)
```

### 제약 조건
- 1 ≤ prices.length ≤ 30,000
- 0 ≤ prices[i] ≤ 10,000

---

## 💡 핵심 아이디어

### 그리디 (Greedy) 접근 ⭐

**핵심 통찰: 오르는 날마다 이익을 챙긴다!**

```
가격: [1, 2, 3, 4, 5]

매일 차이: +1, +1, +1, +1
양수만 합산: 1 + 1 + 1 + 1 = 4

이것은 1에 매수 → 5에 매도와 같은 결과!
```

**왜 이게 최적인가?**
```
가격 그래프:
7
6  *
5     *        *
4           *     *
3        *
2
1  *

모든 오르막 구간의 합 = 최대 이익
(내리막에서는 아무것도 안 함)
```

---

## 🔑 해결 전략

### 방법 1: 그리디 (추천) ⭐

```python
def maxProfit(self, prices: List[int]) -> int:
    max_profit = 0

    for i in range(1, len(prices)):
        # 어제보다 오늘이 비싸면 이익 챙기기
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]

    return max_profit
```

**한 줄로:**
```python
def maxProfit(self, prices: List[int]) -> int:
    return sum(max(prices[i] - prices[i-1], 0) for i in range(1, len(prices)))
```

### 방법 2: DP (Dynamic Programming)

```python
def maxProfit(self, prices: List[int]) -> int:
    # hold: 주식을 들고 있을 때의 최대 이익
    # cash: 주식을 안 들고 있을 때의 최대 이익
    hold = -prices[0]
    cash = 0

    for i in range(1, len(prices)):
        hold = max(hold, cash - prices[i])    # 보유 유지 or 매수
        cash = max(cash, hold + prices[i])    # 현금 유지 or 매도

    return cash
```

---

## 🎯 동작 예시

**입력: [7, 1, 5, 3, 6, 4]**

```
i=1: prices[1]-prices[0] = 1-7 = -6 (음수, 스킵)
i=2: prices[2]-prices[1] = 5-1 = +4 ✓ (profit = 4)
i=3: prices[3]-prices[2] = 3-5 = -2 (음수, 스킵)
i=4: prices[4]-prices[3] = 6-3 = +3 ✓ (profit = 7)
i=5: prices[5]-prices[4] = 4-6 = -2 (음수, 스킵)

결과: 7
```

---

## 🔗 Stock 시리즈 비교

| 문제 | 거래 횟수 | 핵심 전략 |
|------|----------|----------|
| **121. Stock I** | 1번 | min 추적 + max 갱신 |
| **122. Stock II** | 무제한 | 그리디 (오르면 챙기기) |
| **123. Stock III** | 최대 2번 | DP (상태 머신) |
| **188. Stock IV** | 최대 k번 | DP (일반화) |

---

## 🤔 자주하는 실수

### 1. "최저점 매수, 최고점 매도"로 생각
```
# ❌ 잘못된 생각
# [1, 5, 3, 6]에서 1에 매수, 6에 매도 = 5?

# ✅ 올바른 생각
# 1→5 (+4), 3→6 (+3) = 7이 더 크다!
# 매일 오르면 챙기는 게 항상 최적
```

### 2. Stock I과 혼동
```python
# ❌ Stock I 방식 (한 번만 거래)
min_price = float('inf')
max_profit = 0
for price in prices:
    min_price = min(min_price, price)
    max_profit = max(max_profit, price - min_price)

# ✅ Stock II 방식 (여러 번 거래)
max_profit = 0
for i in range(1, len(prices)):
    if prices[i] > prices[i - 1]:
        max_profit += prices[i] - prices[i - 1]
```

---

## 💪 핵심 포인트 체크리스트

- [ ] 그리디 전략의 핵심을 이해했나요? (오르면 무조건 챙기기)
- [ ] 매일 차이를 계산하는 방식이 최적인 이유를 아나요?
- [ ] Stock I과 II의 차이를 설명할 수 있나요?
- [ ] 계속 하락하는 케이스 처리했나요?

---

## 🎯 시간/공간 복잡도

- **시간: O(n)** - 한 번 순회
- **공간: O(1)** - 변수만 사용

---

## 🚀 관련 문제

- LeetCode 121: Best Time to Buy and Sell Stock (1회 거래)
- LeetCode 123: Best Time to Buy and Sell Stock III (최대 2회)
- LeetCode 188: Best Time to Buy and Sell Stock IV (최대 k회)
- LeetCode 309: Best Time to Buy and Sell Stock with Cooldown

화이팅! 그리디의 핵심은 **"지금 이득이면 무조건 챙긴다"** 입니다! 🔥
