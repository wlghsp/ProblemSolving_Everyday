# LeetCode 139. Word Break

## 문제 설명
문자열 `s`와 문자열 배열 `wordDict`가 주어집니다.
`s`를 공백으로 구분된 사전 내 단어들의 연속으로 분할할 수 있으면 `true`를 반환하세요.

**참고:** 사전의 같은 단어를 여러 번 사용할 수 있습니다.

## 예제

### Example 1:
```
입력: s = "leetcode", wordDict = ["leet","code"]
출력: true
설명: "leet" + "code" = "leetcode"로 분할 가능
```

### Example 2:
```
입력: s = "applepenapple", wordDict = ["apple","pen"]
출력: true
설명: "apple" + "pen" + "apple"로 분할 가능
참고: 같은 단어("apple")를 두 번 사용할 수 있음
```

### Example 3:
```
입력: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
출력: false
설명: 어떻게 분할해도 완전히 나눌 수 없음
- "cat" + "sand" + "og" (X - "og"가 사전에 없음)
- "cats" + "and" + "og" (X - "og"가 사전에 없음)
```

## 제약 조건
- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s`와 `wordDict[i]`는 소문자 영문자로만 구성
- `wordDict`의 모든 문자열은 유일함

## 접근 방법

### 방법 1: 동적 계획법 (Dynamic Programming) ⭐ 추천
**핵심 아이디어:**
- `dp[i]` = 문자열 `s[0:i]`가 사전의 단어들로 분할 가능한지 여부
- 각 위치 `i`에서, 이전 위치 `j`부터 `i`까지의 부분 문자열이 사전에 있고
  `dp[j]`가 `true`이면 → `dp[i] = true`

**알고리즘:**
1. `dp` 배열 생성: `dp = [False] * (len(s) + 1)`
2. 초기값: `dp[0] = True` (빈 문자열은 항상 분할 가능)
3. `wordDict`를 Set으로 변환 (O(1) 조회)
4. 각 위치 `i` (1부터 len(s)까지):
   - 각 이전 위치 `j` (0부터 i까지):
     - `dp[j]`가 `True`이고 `s[j:i]`가 사전에 있으면
     - `dp[i] = True`로 설정하고 다음 `i`로
5. `dp[len(s)]` 반환

**시간복잡도:** O(n² × m)
- n = 문자열 길이
- m = 단어 평균 길이 (부분 문자열 생성 및 비교)
- 이중 루프 O(n²), 각 반복에서 부분 문자열 생성 O(m)

**공간복잡도:** O(n + k)
- n = dp 배열
- k = wordDict의 총 문자 수 (Set 저장)

**구현 팁:**
```python
n = len(s)
dp = [False] * (n + 1)
dp[0] = True  # 빈 문자열
word_set = set(wordDict)  # 빠른 조회

for i in range(1, n + 1):
    for j in range(i):
        # s[j:i]가 단어이고, s[0:j]가 분할 가능하면
        if dp[j] and s[j:i] in word_set:
            dp[i] = True
            break  # 이미 True이므로 다음 i로

return dp[n]
```

**최적화 팁:**
- `word_set`으로 O(1) 조회
- `dp[i]`가 True가 되면 즉시 `break`로 불필요한 검사 생략
- 안쪽 루프를 뒤에서부터 돌면서 최장 단어 길이만큼만 검사

### 방법 2: BFS (너비 우선 탐색)
**핵심 아이디어:**
- 각 위치를 노드로 생각
- 현재 위치에서 사전에 있는 단어만큼 점프할 수 있음
- 문자열 끝에 도달할 수 있는지 탐색

**알고리즘:**
1. 큐에 시작 위치 0 추가
2. 방문한 위치를 기록 (무한 루프 방지)
3. 큐에서 위치를 꺼내며:
   - 현재 위치부터 끝까지 순회
   - 부분 문자열이 사전에 있으면 끝 위치를 큐에 추가
   - 끝 위치가 문자열 길이와 같으면 True
4. 큐가 비면 False

**시간복잡도:** O(n² × m)
**공간복잡도:** O(n)

**구현 팁:**
```python
from collections import deque

word_set = set(wordDict)
queue = deque([0])
visited = set()

while queue:
    start = queue.popleft()
    if start in visited:
        continue
    visited.add(start)

    for end in range(start + 1, len(s) + 1):
        if s[start:end] in word_set:
            if end == len(s):
                return True
            queue.append(end)

return False
```

### 방법 3: 재귀 + 메모이제이션 (Top-down DP)
**핵심 아이디어:**
- 현재 위치부터 끝까지 분할 가능한지 재귀적으로 확인
- 메모이제이션으로 중복 계산 방지

**구현 팁:**
```python
def wordBreak(self, s: str, wordDict: List[str]) -> bool:
    word_set = set(wordDict)
    memo = {}

    def can_break(start):
        if start == len(s):
            return True
        if start in memo:
            return memo[start]

        for end in range(start + 1, len(s) + 1):
            if s[start:end] in word_set and can_break(end):
                memo[start] = True
                return True

        memo[start] = False
        return False

    return can_break(0)
```

## 시각화 예제

### Example: s = "leetcode", wordDict = ["leet", "code"]

```
DP 배열 구축 과정:

인덱스:  0   1   2   3   4   5   6   7   8
문자열:     l   e   e   t   c   o   d   e
dp:    [T] [F] [F] [F] [F] [F] [F] [F] [F]

i=1: s[0:1]="l" → 사전에 없음 → dp[1]=False
i=2: s[0:2]="le" → 사전에 없음 → dp[2]=False
i=3: s[0:3]="lee" → 사전에 없음 → dp[3]=False
i=4: s[0:4]="leet" → 사전에 있음! dp[0]=True이므로 → dp[4]=True
     [T] [F] [F] [F] [T] [F] [F] [F] [F]

i=5: s[4:5]="c" (dp[4]=True) → 사전에 없음 → dp[5]=False
i=6: s[4:6]="co" (dp[4]=True) → 사전에 없음 → dp[6]=False
i=7: s[4:7]="cod" (dp[4]=True) → 사전에 없음 → dp[7]=False
i=8: s[4:8]="code" (dp[4]=True) → 사전에 있음! → dp[8]=True
     [T] [F] [F] [F] [T] [F] [F] [F] [T]

결과: dp[8] = True
```

### Example: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]

```
인덱스:  0   1   2   3   4   5   6   7   8   9
문자열:     c   a   t   s   a   n   d   o   g
dp:    [T] [F] [F] [F] [F] [F] [F] [F] [F] [F]

i=3: s[0:3]="cat" → 사전에 있음! → dp[3]=True
     [T] [F] [F] [T] [F] [F] [F] [F] [F] [F]

i=4: s[0:4]="cats" → 사전에 있음! → dp[4]=True
     [T] [F] [F] [T] [T] [F] [F] [F] [F] [F]

i=7: s[3:7]="sand" (dp[3]=True) → 사전에 있음! → dp[7]=True
     s[4:7]="and" (dp[4]=True) → 사전에 있음! → dp[7]=True
     [T] [F] [F] [T] [T] [F] [F] [T] [F] [F]

i=8:
  - s[7:8]="o" (dp[7]=True) → 사전에 없음
  - 다른 조합들도 모두 실패
  → dp[8]=False

i=9:
  - s[7:9]="og" (dp[7]=True) → 사전에 없음
  - 다른 조합들도 모두 실패
  → dp[9]=False

결과: dp[9] = False (분할 불가능)
```

## 주요 포인트

### 1. DP 점화식
```
dp[i] = OR (dp[j] AND s[j:i] in wordDict)
        for all j in [0, i)
```

### 2. 최적화 전략
**Set 사용:**
```python
word_set = set(wordDict)  # O(1) 조회
# list 사용 시 O(k) 조회 (k = wordDict 길이)
```

**최장 단어 길이 제한:**
```python
max_len = max(len(word) for word in wordDict)

for i in range(1, n + 1):
    for j in range(max(0, i - max_len), i):  # 최적화!
        if dp[j] and s[j:i] in word_set:
            dp[i] = True
            break
```

**Early Break:**
```python
if dp[j] and s[j:i] in word_set:
    dp[i] = True
    break  # 더 이상 검사 불필요
```

### 3. 엣지 케이스
- 빈 문자열: `s = ""`
- 사전에 없는 문자: 분할 불가능
- 단어 재사용: "aaaaaaa" with ["aaa", "aaaa"]
- 사전이 비어있음: 분할 불가능

### 4. 흔한 실수
```python
# 잘못된 초기화
dp = [False] * len(s)  # 크기가 1 부족!
# 올바른 초기화
dp = [False] * (len(s) + 1)

# 잘못된 인덱싱
if s[j:i] in wordDict:  # wordDict는 list (느림)
# 올바른 방법
if s[j:i] in word_set:  # Set 사용 (빠름)
```

## 관련 문제
- LeetCode 140. Word Break II (모든 가능한 분할 찾기)
- LeetCode 472. Concatenated Words
- LeetCode 1043. Partition Array for Maximum Sum

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| Bottom-up DP | O(n²×m) | O(n) | 반복문, 스택 안전 | - |
| BFS | O(n²×m) | O(n) | 직관적 | 큐 오버헤드 |
| Top-down DP | O(n²×m) | O(n) | 재귀적 사고 | 스택 깊이 제한 |

## 추천 풀이
**Bottom-up DP (반복문)**
- 가장 효율적이고 안정적
- 면접에서 선호되는 방식
- 최적화 적용이 쉬움

## 디버깅 팁
1. DP 배열을 출력하며 각 단계 확인
2. 작은 예제로 손으로 시뮬레이션
3. `dp[0] = True` 초기화 확인
4. 배열 크기 `n+1` 확인
5. 인덱스 범위 확인 (`range(1, n+1)`)
