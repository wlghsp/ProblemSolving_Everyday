# LeetCode 141. Linked List Cycle

## 문제 설명
연결 리스트의 헤드가 주어질 때, 리스트에 사이클이 있는지 판별하세요.

연결 리스트에 사이클이 있다는 것은, 리스트 내에서 `next` 포인터를 계속 따라가면 다시 같은 노드에 도달할 수 있다는 의미입니다.

내부적으로 `pos`는 꼬리의 `next` 포인터가 연결되는 노드의 인덱스를 나타냅니다. `pos`는 파라미터로 전달되지 않습니다.

사이클이 있으면 `true`를, 없으면 `false`를 반환하세요.

## 예제

### Example 1:
```
입력: head = [3,2,0,-4], pos = 1
출력: true
설명: 리스트에 사이클이 있으며, 꼬리가 인덱스 1의 노드(값 2)에 연결됩니다.

시각화:
3 -> 2 -> 0 -> -4
     ↑__________↓
```

### Example 2:
```
입력: head = [1,2], pos = 0
출력: true
설명: 리스트에 사이클이 있으며, 꼬리가 인덱스 0의 노드(값 1)에 연결됩니다.

시각화:
1 -> 2
↑____↓
```

### Example 3:
```
입력: head = [1], pos = -1
출력: false
설명: 사이클이 없습니다.

시각화:
1 -> null
```

## 제약 조건
- 리스트의 노드 개수는 `[0, 10^4]` 범위
- `-10^5 <= Node.val <= 10^5`
- `pos`는 `-1` 또는 유효한 인덱스

## 접근 방법

### 방법 1: Floyd's Cycle Detection Algorithm (토끼와 거북이) ⭐ 추천
**핵심 아이디어:**
- 두 개의 포인터를 서로 다른 속도로 이동
- 느린 포인터(거북이): 한 번에 1칸
- 빠른 포인터(토끼): 한 번에 2칸
- 사이클이 있으면 언젠가 두 포인터가 만남
- 사이클이 없으면 빠른 포인터가 끝(null)에 도달

**알고리즘:**
1. 느린 포인터 `slow`와 빠른 포인터 `fast`를 모두 `head`에서 시작
2. 반복:
   - `slow`를 1칸 이동
   - `fast`를 2칸 이동
   - `slow == fast`이면 사이클 존재 → `True` 반환
   - `fast`나 `fast.next`가 `None`이면 사이클 없음 → `False` 반환

**왜 만날까?**
- 사이클이 있으면 두 포인터 모두 사이클 안에 갇힘
- 매 단계마다 빠른 포인터가 느린 포인터와의 거리를 1씩 줄임
- 결국 거리가 0이 되어 만남

**시간복잡도:** O(n)
- 사이클이 없는 경우: `fast`가 끝까지 도달 → O(n)
- 사이클이 있는 경우: 최악의 경우 사이클 내에서 한 바퀴 돌며 만남 → O(n)

**공간복잡도:** O(1)
- 두 개의 포인터만 사용

**구현 팁:**
```python
slow = fast = head

while fast and fast.next:
    slow = slow.next         # 1칸
    fast = fast.next.next    # 2칸

    if slow == fast:         # 만났다!
        return True

return False  # fast가 끝에 도달 = 사이클 없음
```

**주의사항:**
- `fast.next`도 체크해야 함 (2칸 이동 시 `NoneType` 에러 방지)
- 빈 리스트나 노드 1개인 경우도 자동으로 처리됨

### 방법 2: 해시 테이블 (Set 사용)
**핵심 아이디어:**
- 방문한 노드를 Set에 저장
- 이미 방문한 노드를 다시 만나면 사이클 존재

**알고리즘:**
1. 빈 Set `visited` 생성
2. 현재 노드부터 시작하여 순회:
   - 현재 노드가 `visited`에 있으면 → 사이클 존재 → `True`
   - 현재 노드를 `visited`에 추가
   - 다음 노드로 이동
3. `None`에 도달하면 → 사이클 없음 → `False`

**시간복잡도:** O(n)
- 각 노드를 최대 한 번씩 방문

**공간복잡도:** O(n)
- Set에 모든 노드를 저장할 수 있음

**구현 팁:**
```python
visited = set()
current = head

while current:
    if current in visited:  # 또는 id(current) in visited
        return True
    visited.add(current)    # 또는 visited.add(id(current))
    current = current.next

return False
```

**장단점:**
- 장점: 직관적이고 이해하기 쉬움
- 단점: 추가 공간 O(n) 사용, 최적이 아님

### 방법 3: 노드 변조 (비추천)
**아이디어:** 방문한 노드를 표시하기 위해 값 변경 또는 특수 마커 사용
**문제점:**
- 원본 데이터 손상
- 면접에서 좋지 않은 인상
- 실제 프로덕션 코드에서 사용 불가

## 시각화 예제

### Floyd's Algorithm 동작 과정

```
리스트: 3 -> 2 -> 0 -> -4
             ↑__________↓

초기 상태:
slow, fast
  ↓     ↓
  3  -> 2  -> 0  -> -4
        ↑__________↓

1단계:
slow = slow.next (1칸)
fast = fast.next.next (2칸)

        slow  fast
          ↓     ↓
  3  -> 2  -> 0  -> -4
        ↑__________↓

2단계:
        fast
          ↓
  3  -> 2  -> 0  -> -4
        ↑__________↓
               ↑
             slow

3단계:
             slow, fast (만남!)
               ↓
  3  -> 2  -> 0  -> -4
        ↑__________↓

결과: True (사이클 감지)
```

### 사이클이 없는 경우

```
리스트: 1 -> 2 -> 3 -> null

초기:
slow, fast
  ↓     ↓
  1  -> 2  -> 3  -> null

1단계:
        slow  fast
          ↓     ↓
  1  -> 2  -> 3  -> null

2단계:
              slow  fast
                ↓     ↓
  1  -> 2  -> 3  -> null

fast.next가 None이므로 종료
결과: False (사이클 없음)
```

## 주요 포인트

### 1. Floyd's Algorithm의 수학적 증명
**왜 반드시 만날까?**
- 사이클 안에서 두 포인터의 상대속도는 1
- 매 단계마다 거리가 1씩 줄어듦
- 사이클 길이가 유한하므로 반드시 만남

**몇 단계만에 만날까?**
- 최악의 경우: O(n)
- 평균적으로 사이클 길이만큼의 단계 내에 만남

### 2. 엣지 케이스
- 빈 리스트: `head == None`
- 노드 1개: 사이클 불가능 (자기 자신을 가리키는 경우는 가능)
- 노드 2개: pos가 0이면 사이클

### 3. 포인터 체크 순서
```python
# 올바른 순서
while fast and fast.next:  # fast.next를 먼저 체크!
    fast = fast.next.next

# 잘못된 순서
while fast.next and fast:  # fast가 None이면 fast.next 접근 시 에러!
```

### 4. 비교 연산
```python
# 노드 자체를 비교 (추천)
if slow == fast:

# ID를 비교 (동일한 효과)
if id(slow) == id(fast):

# 값을 비교 (잘못된 방법!)
if slow.val == fast.val:  # 값이 같아도 다른 노드일 수 있음!
```

## Follow-up: O(1) 공간으로 해결할 수 있나요?
**답변:** 네! Floyd's Cycle Detection Algorithm이 바로 O(1) 공간 복잡도를 갖습니다.

## 관련 문제
- LeetCode 142. Linked List Cycle II (사이클 시작 노드 찾기)
- LeetCode 202. Happy Number (Floyd's Algorithm 응용)
- LeetCode 287. Find the Duplicate Number (사이클 감지 응용)

## 시간/공간 복잡도 비교

| 방법 | 시간복잡도 | 공간복잡도 | 장점 | 단점 |
|------|-----------|-----------|------|------|
| Floyd's | O(n) | O(1) | 최적의 공간, 우아한 알고리즘 | 처음엔 이해하기 어려울 수 있음 |
| Hash Set | O(n) | O(n) | 직관적, 구현 간단 | 추가 메모리 필요 |
| 노드 변조 | O(n) | O(1) | - | 데이터 손상, 비현실적 |

## 추천 풀이
**Floyd's Cycle Detection Algorithm (토끼와 거북이)**
- 최적의 시간/공간 복잡도
- 면접에서 가장 선호되는 방식
- 한 번 이해하면 여러 문제에 응용 가능!

## 디버깅 팁
사이클 감지가 잘 안 될 때:
1. `fast`와 `fast.next` 체크 순서 확인
2. 포인터 이동 순서 확인 (비교 전에 이동하지 않기)
3. 빈 리스트/1개 노드 케이스 테스트
4. 직접 그림 그려가며 시뮬레이션
