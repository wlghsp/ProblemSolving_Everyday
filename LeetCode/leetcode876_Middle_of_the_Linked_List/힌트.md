# LeetCode 876. Middle of the Linked List - 초보자 힌트

## 문제 요약
연결 리스트(Linked List)의 중간 노드를 찾는 문제입니다.
- 노드 개수가 **홀수**면: 정확히 중간 노드 반환
- 노드 개수가 **짝수**면: 두 번째 중간 노드 반환

### 예시
```
입력: [1,2,3,4,5]
출력: [3,4,5] (3번 노드부터 반환)

입력: [1,2,3,4,5,6]
출력: [4,5,6] (4번 노드부터 반환, 두 번째 중간)
```

---

## 💡 핵심 아이디어

### 방법 1: 두 번 순회하기 (초보자 추천)
가장 직관적인 방법입니다!

**단계:**
1. 첫 번째 순회: 리스트의 **전체 길이**를 센다
2. 중간 위치를 계산한다 (길이 // 2)
3. 두 번째 순회: 중간 위치까지 이동한다

**힌트:**
- 길이가 5라면? 중간은 2번 인덱스 (0부터 시작)
- 길이가 6이라면? 중간은 3번 인덱스

```python
# 의사코드
count = 0
current = head
# 1단계: 길이 세기
while current:
    count += 1
    current = current.next

# 2단계: 중간까지 이동
middle_pos = count // 2
current = head
for i in range(middle_pos):
    current = current.next

return current
```

---

### 방법 2: 토끼와 거북이 (Two Pointers) ⭐
**더 효율적인 방법!** - 한 번만 순회합니다

**핵심 개념:**
- **거북이(slow)**: 한 칸씩 이동
- **토끼(fast)**: 두 칸씩 이동
- 토끼가 끝에 도달하면, 거북이는 정확히 중간에 위치!

**왜 이게 작동할까?**
- 토끼가 2배 빠르게 움직이니까
- 토끼가 끝(100m)에 도달할 때, 거북이는 중간(50m)에 있음

```python
# 의사코드
slow = head  # 거북이
fast = head  # 토끼

while fast and fast.next:
    slow = slow.next      # 한 칸
    fast = fast.next.next # 두 칸

return slow  # 거북이가 중간에 도착!
```

**시각화:**
```
[1] -> [2] -> [3] -> [4] -> [5]
 S,F

[1] -> [2] -> [3] -> [4] -> [5]
       S      F

[1] -> [2] -> [3] -> [4] -> [5]
              S             F (끝)

중간 찾음! ✓
```

---

## 🤔 생각해볼 점

1. **Linked List 순회 기본**
   - `current = head`로 시작
   - `current = current.next`로 다음으로 이동
   - `current is None`이면 끝

2. **종료 조건 주의**
   - `while fast and fast.next:`를 써야 하는 이유?
   - `fast.next`를 확인 안 하면 어떻게 될까?

3. **짝수 개일 때**
   - [1,2,3,4]에서 어떻게 동작하는지 직접 그려보기

---

## 📝 단계별 학습 순서

### Step 1: 기본부터 (쉬움)
먼저 방법 1(두 번 순회)로 구현해보세요.
- 코드가 더 길지만 이해하기 쉽습니다
- Linked List 순회에 익숙해집니다

### Step 2: 최적화 (보통)
방법 2(Two Pointers)로 개선해보세요.
- 시간 복잡도는 같지만 (O(n)) 더 우아합니다
- 한 번만 순회하니 더 효율적입니다

### Step 3: 검증하기
다양한 케이스로 테스트:
- 노드 1개: [1]
- 노드 2개: [1,2]
- 홀수 개: [1,2,3,4,5]
- 짝수 개: [1,2,3,4,5,6]

---

## ⚠️ 주의사항

1. **None 체크**
   - `head`가 None일 수 있나요? (문제 조건 확인)
   - `fast.next`를 확인 안 하고 `fast.next.next`를 쓰면?

2. **인덱스 실수**
   - 배열과 달리 Linked List는 인덱스로 바로 접근 못함
   - 반드시 순회해야 함

---

## 🎯 시간/공간 복잡도

- **방법 1 (두 번 순회)**
  - 시간: O(n) - 2번 순회지만 상수는 무시
  - 공간: O(1) - 추가 메모리 안 씀

- **방법 2 (Two Pointers)**
  - 시간: O(n) - 1번 순회
  - 공간: O(1) - 포인터 2개만 사용

---

## 💪 도전 과제

1. 먼저 방법 1로 풀어보세요
2. 통과하면 방법 2로 리팩토링해보세요
3. 각 방법의 장단점을 비교해보세요

화이팅! 🚀
