# 121. Best Time to Buy and Sell Stock

## 문제 요약
정수 배열 `prices`에서 `prices[i]`는 i번째 날의 주식 가격. **한 번** 사고 한 번 팔아서 최대 이익을 구하라. 이익이 없으면 0 반환.

## 예시
```
Input: prices = [7, 1, 5, 3, 6, 4]
Output: 5 (1에 사서 6에 팔면 6-1=5)

Input: prices = [7, 6, 4, 3, 1]
Output: 0 (가격이 계속 떨어지므로 이익 불가)
```

## 제약 조건
- 1 <= prices.length <= 10^5
- 0 <= prices[i] <= 10^4

---

## Level 1 - 방향 힌트
- 한 번의 순회(O(n))로 풀 수 있다
- 지금까지의 **최소 가격**을 추적하면서, 현재 가격과의 차이로 **최대 이익**을 갱신한다

---

## Level 2 - 구조 힌트
```python
def maxProfit(self, prices):
    # 1. 최소 가격을 첫 번째 값으로 초기화

    # 2. 최대 이익을 0으로 초기화

    # 3. prices를 순회하면서
        # 현재 가격이 최소 가격보다 작으면? → 최소 가격 갱신
        # 현재 가격 - 최소 가격이 최대 이익보다 크면? → 최대 이익 갱신

    # 4. 최대 이익 반환
```

---

## Level 3 - 전체 풀이

```python
def maxProfit(self, prices):
    min_price = float('inf')  # 지금까지 본 최소 가격
    max_profit = 0             # 지금까지의 최대 이익

    for price in prices:
        # 더 싼 가격을 발견하면 갱신
        if price < min_price:
            min_price = price
        # 현재 가격에 팔았을 때 이익이 최대인지 확인
        elif price - min_price > max_profit:
            max_profit = price - min_price

    return max_profit
```

### 복잡도
- 시간: O(n) — 한 번 순회
- 추가 공간: O(1) — 변수 2개만 사용

### 자주하는 실수
- 최소 가격 초기값을 `prices[0]` 대신 `0`으로 설정하는 실수
- 사고 나서 파는 건데 **같은 날 사고팔기**는 이익 0 (문제없음)
- 122번(여러 번 거래)과 혼동 — 이 문제는 **한 번만** 거래

### 122번과의 차이
| | 121 (이 문제) | 122 |
|---|---|---|
| 거래 횟수 | 1번 | 무제한 |
| 접근법 | 최소가격 추적 | 모든 상승구간 합산 |
| 핵심 | min_price, max_profit | price[i] - price[i-1] > 0 |

## 유사 문제
- LeetCode 122. Best Time to Buy and Sell Stock II (Easy) — 무제한 거래
- LeetCode 123. Best Time to Buy and Sell Stock III (Hard) — 최대 2번 거래
- LeetCode 53. Maximum Subarray (Medium) — 같은 "최소/최대 추적" 패턴
- 백준 11055. 가장 큰 증가하는 부분 수열 (Silver II)
