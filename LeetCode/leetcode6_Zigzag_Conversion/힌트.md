# LeetCode 6. Zigzag Conversion - 힌트

## 문제 요약
문자열을 **지그재그 패턴**으로 배치한 후, 행별로 읽어서 반환하는 문제입니다.

### 예시 1: numRows = 3
```
입력: "PAYPALISHIRING", numRows = 3

지그재그 배치:
P   A   H   N
A P L S I I G
Y   I   R

행별로 읽기: "PAHNAPLSIIGYIR"
```

### 예시 2: numRows = 4
```
입력: "PAYPALISHIRING", numRows = 4

지그재그 배치:
P     I     N
A   L S   I G
Y A   H R
P     I

행별로 읽기: "PINALSIGYAHRPI"
```

### 제약 조건
- 1 ≤ s.length ≤ 1000
- 1 ≤ numRows ≤ 1000

---

## 💡 핵심 아이디어

### 지그재그 패턴 이해하기

**문자가 이동하는 방향:**
```
행 0: ↓
행 1: ↓
행 2: ↓ (바닥 도달)
행 1: ↑
행 0: ↑ (천장 도달)
행 1: ↓
... 반복
```

**핵심 포인트:**
- 아래로 이동하다가 **바닥(numRows-1)**에 도달하면 방향 전환
- 위로 이동하다가 **천장(0)**에 도달하면 방향 전환

---

## 🔑 해결 전략

### 방법 1: 행별 문자열 저장 (가장 직관적) ⭐

```python
def convert(self, s: str, numRows: int) -> str:
    # 엣지 케이스
    if numRows == 1 or numRows >= len(s):
        return s

    # 각 행을 저장할 리스트
    rows = [''] * numRows
    current_row = 0
    going_down = False

    for char in s:
        rows[current_row] += char

        # 방향 전환 (천장 또는 바닥)
        if current_row == 0 or current_row == numRows - 1:
            going_down = not going_down

        # 다음 행으로 이동
        current_row += 1 if going_down else -1

    return ''.join(rows)
```

**동작 예시 (numRows = 3):**
```
P → row 0, going_down = True
A → row 1, going_down = True
Y → row 2, going_down = False (바닥!)
P → row 1, going_down = False
A → row 0, going_down = True (천장!)
L → row 1, going_down = True
...

결과:
rows[0] = "PAHN"
rows[1] = "APLSIIG"
rows[2] = "YIR"
```

---

### 방법 2: 수학적 인덱스 계산

**주기(cycle) 패턴 활용:**
- 한 주기 길이: `cycle = 2 * numRows - 2`
- 첫 번째 행: 인덱스 0, cycle, 2*cycle, ...
- 마지막 행: 인덱스 numRows-1, numRows-1+cycle, ...
- 중간 행: 위 + 대각선 위치

```python
def convert(self, s: str, numRows: int) -> str:
    if numRows == 1 or numRows >= len(s):
        return s

    result = []
    n = len(s)
    cycle = 2 * numRows - 2

    for row in range(numRows):
        for i in range(row, n, cycle):
            result.append(s[i])

            # 중간 행은 대각선 위치도 추가
            diagonal = i + cycle - 2 * row
            if 0 < row < numRows - 1 and diagonal < n:
                result.append(s[diagonal])

    return ''.join(result)
```

---

## 🎯 시각화로 이해하기

### numRows = 4일 때 인덱스
```
행 0:  0           6           12
행 1:  1       5   7       11  13
행 2:  2   4       8   10
행 3:  3           9

cycle = 2 * 4 - 2 = 6
```

**패턴:**
- 행 0: 0, 6, 12 (cycle 간격)
- 행 1: 1, 5, 7, 11, 13 (1과 5는 대각선 관계)
- 행 2: 2, 4, 8, 10
- 행 3: 3, 9 (cycle 간격)

---

## 🎯 방법별 비교

| 방법 | 시간 | 공간 | 특징 |
|------|------|------|------|
| **행별 저장** | O(n) | O(n) | 직관적, 구현 쉬움 |
| **수학적 계산** | O(n) | O(n) | 효율적, 이해 어려움 |

---

## 🤔 자주하는 실수

### 1. 엣지 케이스 처리 안 함
```python
# ❌ numRows = 1이면 무한 루프
if current_row == 0 or current_row == numRows - 1:
    going_down = not going_down

# ✅ 먼저 엣지 케이스 처리
if numRows == 1 or numRows >= len(s):
    return s
```

### 2. 방향 전환 시점 실수
```python
# ❌ 문자 추가 전에 방향 전환
if current_row == 0 or current_row == numRows - 1:
    going_down = not going_down
rows[current_row] += char  # 잘못된 위치

# ✅ 문자 추가 후 방향 전환
rows[current_row] += char
if current_row == 0 or current_row == numRows - 1:
    going_down = not going_down
```

### 3. going_down 초기값 실수
```python
# ❌ True로 시작하면 첫 문자에서 바로 방향 전환
going_down = True
# row 0에서 시작 → 바로 방향 전환 → going_down = False

# ✅ False로 시작
going_down = False
# row 0에서 시작 → 방향 전환 → going_down = True → 아래로 이동
```

---

## 📝 전체 코드 (추천)

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        # 엣지 케이스
        if numRows == 1 or numRows >= len(s):
            return s

        # 각 행을 저장할 리스트
        rows = [''] * numRows
        current_row = 0
        going_down = False

        for char in s:
            # 현재 행에 문자 추가
            rows[current_row] += char

            # 천장(0) 또는 바닥(numRows-1)에 도달하면 방향 전환
            if current_row == 0 or current_row == numRows - 1:
                going_down = not going_down

            # 다음 행으로 이동
            current_row += 1 if going_down else -1

        # 모든 행을 합쳐서 반환
        return ''.join(rows)
```

---

## 💪 핵심 포인트 체크리스트

- [ ] 지그재그 패턴의 방향 전환 조건을 이해했나요?
- [ ] `numRows == 1`인 엣지 케이스를 처리했나요?
- [ ] `going_down` 초기값이 `False`인 이유를 아나요?
- [ ] 문자 추가와 방향 전환의 순서를 이해했나요?

---

## 🎯 시간/공간 복잡도

- **시간 복잡도: O(n)** - 문자열 한 번 순회
- **공간 복잡도: O(n)** - 결과 문자열 저장

---

## 🚀 추가 도전 과제

1. **수학적 방법으로 풀어보기**
   - cycle 패턴을 이용한 인덱스 계산
   - 더 효율적이지만 이해하기 어려움

2. **관련 문제:**
   - LeetCode 1260: Shift 2D Grid
   - LeetCode 498: Diagonal Traverse

---

## 💡 디버깅 팁

막혔다면 각 단계를 출력해보세요:

```python
for char in s:
    print(f"char={char}, row={current_row}, going_down={going_down}")
    rows[current_row] += char
    if current_row == 0 or current_row == numRows - 1:
        going_down = not going_down
    current_row += 1 if going_down else -1

print(f"rows: {rows}")
```

화이팅! 패턴 인식 문제는 시각화가 핵심입니다! 🔥
